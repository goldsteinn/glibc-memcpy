From 69d1205f34d85dc7f102b8e33c658d19f1f4aede Mon Sep 17 00:00:00 2001
From: Noah Goldstein <goldstein.w.n@gmail.com>
Date: Thu, 23 Sep 2021 20:38:25 -0500
Subject: [PATCH 12/13] tmp

---
 .../multiarch/memset-vec-unaligned-erms.S     | 81 +++++++++----------
 1 file changed, 40 insertions(+), 41 deletions(-)

diff --git a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
index 818e69d209..3fb9193b31 100644
--- a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
+++ b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
@@ -181,49 +181,21 @@ ENTRY (MEMSET_SYMBOL (__memset, unaligned_erms))
 	VMOVU	%VEC(0), -VEC_SIZE(%rax, %rdx)
 	VZEROUPPER_RETURN
 #endif
-	.p2align 4,, 10
-L(last_2x_vec):    
-	VMOVU	%VEC(0), (VEC_SIZE * -2)(%rdx)
-	VMOVU	%VEC(0), (VEC_SIZE * -1)(%rdx)
-    VZEROUPPER_RETURN
-
-#if defined USE_MULTIARCH && IS_IN (libc)
+#undef LOOP_4X_OFFSET
+#define LOOP_4X_OFFSET (VEC_SIZE * -4)
 	.p2align 4
-L(stosb_more_2x_vec):
-	cmp	$2048, %RDX_LP
-	ja	L(stosb_close)
-#endif
-    L(more_2x_vec):
-    addq    %rdi, %rdx
-    subq    $-(VEC_SIZE * 4), %rdi
-	/* Stores to first 2x VEC before cmp as any path forward will
-	   require it.  */
-	VMOVU	%VEC(0), (%rax)
-	VMOVU	%VEC(0), VEC_SIZE(%rax)
-	cmpq	%rdx, %rdi
-	jae	L(last_2x_vec)
-	VMOVU	%VEC(0), (VEC_SIZE * 2)(%rax)
-	VMOVU	%VEC(0), (VEC_SIZE * 3)(%rax)
-	/* Try and have this cmp/jcc on same cache line as target and
-	fallthrough.  */
-    addq    $-(VEC_SIZE * 4), %rdx
-	cmpq	%rdx, %rdi
-	jae	L(last_4x_vec)
-    andq    $(VEC_SIZE * -2), %rdi
+L(loop_4x_vec):
+	leaq	(VEC_SIZE * 4 - LOOP_4X_OFFSET)(%rax), %rcx
+	andq	$-(VEC_SIZE * 2), %rcx
 	.p2align 4
 L(loop):
-	VMOVA	%VEC(0), (VEC_SIZE * 0)(%rdi)
-	VMOVA	%VEC(0), (VEC_SIZE * 1)(%rdi)
-	VMOVA	%VEC(0), (VEC_SIZE * 2)(%rdi)
-	VMOVA	%VEC(0), (VEC_SIZE * 3)(%rdi)
-	subq	$-(VEC_SIZE * 4), %rdi
-	cmpq	%rdx, %rdi
+	VMOVA	%VEC(0), (LOOP_4X_OFFSET)(%rcx)
+	VMOVA	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE)(%rcx)
+	VMOVA	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 2)(%rcx)
+	VMOVA	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 3)(%rcx)
+	subq	$-(VEC_SIZE * 4), %rcx
+	cmpq	%rdi, %rcx
 	jb	L(loop)
-L(last_4x_vec):    
-	VMOVU	%VEC(0), (VEC_SIZE * 0)(%rdx)
-	VMOVU	%VEC(0), (VEC_SIZE * 1)(%rdx)
-	VMOVU	%VEC(0), (VEC_SIZE * 2)(%rdx)
-	VMOVU	%VEC(0), (VEC_SIZE * 3)(%rdx)
 L(return):
 #if VEC_SIZE > 16
 	ZERO_UPPER_VEC_REGISTERS_RETURN
@@ -231,8 +203,6 @@ L(return):
 	ret
 #endif
 
-
-
 	.p2align 4,, 10
 L(stosb_close):
 	movzbl	%sil, %eax
@@ -242,6 +212,35 @@ L(stosb_close):
 	mov	%RDX_LP, %RAX_LP
 	VZEROUPPER_RETURN
 
+
+#if defined USE_MULTIARCH && IS_IN (libc)
+	.p2align 4
+L(stosb_more_2x_vec):
+	cmp	$2048, %RDX_LP
+	ja	L(stosb_close)
+#endif
+L(more_2x_vec):
+	addq	%rdx, %rdi
+	/* Stores to first 2x VEC before cmp as any path forward will
+	   require it.  */
+	VMOVU	%VEC(0), (%rax)
+	VMOVU	%VEC(0), VEC_SIZE(%rax)
+	VMOVU	%VEC(0), (VEC_SIZE * -1)(%rdi)
+    VMOVU	%VEC(0), (VEC_SIZE * -2)(%rdi)
+	cmpq	$(VEC_SIZE * 4), %rdx
+	jbe	L(return)
+	VMOVU	%VEC(0), (VEC_SIZE * -3)(%rdi)
+    VMOVU	%VEC(0), (VEC_SIZE * -4)(%rdi)
+	VMOVU	%VEC(0), (VEC_SIZE * 2)(%rax)
+	VMOVU	%VEC(0), (VEC_SIZE * 3)(%rax)
+	/* Try and have this cmp/jcc on same cache line as target and
+	   fallthrough.  */
+	cmpq	$(VEC_SIZE * 8), %rdx
+	ja	L(loop_4x_vec)
+	VZEROUPPER_RETURN
+
+
+
 	.p2align 4,, 10
 L(less_vec):
 	/* Less than 1 VEC.  */
-- 
2.25.1

