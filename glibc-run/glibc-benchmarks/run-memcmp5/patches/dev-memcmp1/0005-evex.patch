From f047115660e0971c27e2b74eb604436635007c0a Mon Sep 17 00:00:00 2001
From: Noah Goldstein <goldstein.w.n@gmail.com>
Date: Mon, 6 Sep 2021 02:01:47 -0400
Subject: [PATCH 05/12] evex

---
 sysdeps/x86_64/multiarch/memcmp-evex-movbe.S | 379 +++++++++++++------
 1 file changed, 262 insertions(+), 117 deletions(-)

diff --git a/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S b/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S
index 654dc7ac8c..7996c54e9a 100644
--- a/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S
+++ b/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S
@@ -52,6 +52,16 @@
 #  define VPCMP	vpcmpub
 # endif
 
+# ifdef USE_AS_BCMP
+#  define LAST_4X_OFFSET	(VEC_SIZE	*	-4)
+#  define LAST_4X_S2	rsi,	%rdx,	CHAR_SIZE
+#  define TEST_REG	eax
+# else
+#  define LAST_4X_OFFSET	0
+#  define LAST_4X_S2	rsi
+#  define TEST_REG	ecx
+# endif
+
 # define VEC_SIZE	32
 # define PAGE_SIZE	4096
 # define CHAR_PER_VEC	(VEC_SIZE / CHAR_SIZE)
@@ -83,16 +93,22 @@ ENTRY (MEMCMP)
 	cmp	$CHAR_PER_VEC, %RDX_LP
 	jb	L(less_vec)
 
-	/* From VEC to 2 * VEC.  No branch when size == VEC_SIZE.  */
+	/* From VEC to 2 * VEC.  No branch when size == VEC_SIZE.
+	 */
 	VMOVU	(%rsi), %YMM1
-	/* Use compare not equals to directly check for mismatch.  */
+	/* Use compare not equals to directly check for mismatch.
+	 */
 	VPCMP	$4, (%rdi), %YMM1, %k1
 	kmovd	%k1, %eax
 	/* NB: eax must be destination register if going to
-	   L(return_vec_[0,2]). For L(return_vec_3 destination register
-	   must be ecx.  */
+	   L(return_vec_[0,2]). For L(return_vec_3 destination
+	   register must be ecx.  */
 	testl	%eax, %eax
+# ifdef USE_AS_BCMP
+	jnz	L(return_neq0)
+# else
 	jnz	L(return_vec_0)
+# endif
 
 	cmpq	$(CHAR_PER_VEC * 2), %rdx
 	jbe	L(last_1x_vec)
@@ -102,8 +118,11 @@ ENTRY (MEMCMP)
 	VPCMP	$4, VEC_SIZE(%rdi), %YMM2, %k1
 	kmovd	%k1, %eax
 	testl	%eax, %eax
+# ifdef USE_AS_BCMP
+	jnz	L(return_neq0)
+# else
 	jnz	L(return_vec_1)
-
+# endif
 	/* Less than 4 * VEC.  */
 	cmpq	$(CHAR_PER_VEC * 4), %rdx
 	jbe	L(last_2x_vec)
@@ -113,69 +132,88 @@ ENTRY (MEMCMP)
 	VPCMP	$4, (VEC_SIZE * 2)(%rdi), %YMM3, %k1
 	kmovd	%k1, %eax
 	testl	%eax, %eax
+# ifdef USE_AS_BCMP
+	jnz	L(return_neq0)
+# else
 	jnz	L(return_vec_2)
-
+# endif
 	VMOVU	(VEC_SIZE * 3)(%rsi), %YMM4
 	VPCMP	$4, (VEC_SIZE * 3)(%rdi), %YMM4, %k1
-	kmovd	%k1, %ecx
-	testl	%ecx, %ecx
+	kmovd	%k1, %TEST_REG
+	testl	%TEST_REG, %TEST_REG
+# ifdef USE_AS_BCMP
+	jnz	L(return_neq0)
+# else
 	jnz	L(return_vec_3)
-
-	/* Zero YMM0. 4x VEC reduction is done with vpxor + vtern so
-	   compare with zero to get a mask is needed.  */
+# endif
+	/* Zero YMM0. 4x VEC reduction is done with vpxor + vtern
+	   so compare with zero to get a mask is needed.  */
 	vpxorq	%XMM0, %XMM0, %XMM0
 
 	/* Go to 4x VEC loop.  */
 	cmpq	$(CHAR_PER_VEC * 8), %rdx
 	ja	L(more_8x_vec)
 
-	/* Handle remainder of size = 4 * VEC + 1 to 8 * VEC without any
-	   branches.  */
+	/* Handle remainder of size = 4 * VEC + 1 to 8 * VEC
+	   without any branches.  */
 
-	/* Load first two VEC from s2 before adjusting addresses.  */
+	/* Load first two VEC from s2 before adjusting addresses.
+	 */
 	VMOVU	-(VEC_SIZE * 4)(%rsi, %rdx, CHAR_SIZE), %YMM1
 	VMOVU	-(VEC_SIZE * 3)(%rsi, %rdx, CHAR_SIZE), %YMM2
+# ifdef USE_AS_BCMP
+#  ifdef USE_AS_WMEMCMP
+	leaq	(%rdi, %rdx, CHAR_SIZE), %rdi
+#  else
+	addq	%rdx, %rdi
+#  endif
+# else
 	leaq	-(4 * VEC_SIZE)(%rdi, %rdx, CHAR_SIZE), %rdi
 	leaq	-(4 * VEC_SIZE)(%rsi, %rdx, CHAR_SIZE), %rsi
-
+# endif
 	/* Wait to load from s1 until addressed adjust due to
 	   unlamination of microfusion with complex address mode.  */
 
-	/* vpxor will be all 0s if s1 and s2 are equal. Otherwise it
-	   will have some 1s.  */
-	vpxorq	(%rdi), %YMM1, %YMM1
-	vpxorq	(VEC_SIZE)(%rdi), %YMM2, %YMM2
+	/* vpxor will be all 0s if s1 and s2 are equal. Otherwise
+	   it will have some 1s.  */
+	vpxorq	(LAST_4X_OFFSET)(%rdi), %YMM1, %YMM1
+	vpxorq	(LAST_4X_OFFSET + VEC_SIZE)(%rdi), %YMM2, %YMM2
 
-	VMOVU	(VEC_SIZE * 2)(%rsi), %YMM3
-	vpxorq	(VEC_SIZE * 2)(%rdi), %YMM3, %YMM3
+	VMOVU	(LAST_4X_OFFSET + VEC_SIZE * 2)(%LAST_4X_S2), %YMM3
+	vpxorq	(LAST_4X_OFFSET + VEC_SIZE * 2)(%rdi), %YMM3, %YMM3
 	/* Or together YMM1, YMM2, and YMM3 into YMM3.  */
 	vpternlogd $0xfe, %YMM1, %YMM2, %YMM3
 
-	VMOVU	(VEC_SIZE * 3)(%rsi), %YMM4
-	/* Ternary logic to xor (VEC_SIZE * 3)(%rdi) with YMM4 while
-	   oring with YMM3. Result is stored in YMM4.  */
-	vpternlogd $0xde, (VEC_SIZE * 3)(%rdi), %YMM3, %YMM4
-	/* Compare YMM4 with 0. If any 1s s1 and s2 don't match.  */
+	VMOVU	(LAST_4X_OFFSET + VEC_SIZE * 3)(%LAST_4X_S2), %YMM4
+	/* Ternary logic to xor (VEC_SIZE * 3)(%rdi) with YMM4
+	   while oring with YMM3. Result is stored in YMM4.  */
+	vpternlogd $0xde, (LAST_4X_OFFSET + VEC_SIZE * 3)(%rdi), %YMM3, %YMM4
+	/* Compare YMM4 with 0. If any 1s s1 and s2 don't match.
+	 */
 	VPCMP	$4, %YMM4, %YMM0, %k1
-	kmovd	%k1, %ecx
-	testl	%ecx, %ecx
+	kmovd	%k1, %TEST_REG
+# ifndef USE_AS_BCMP
+	testl	%TEST_REG, %TEST_REG
 	jnz	L(return_vec_0_1_2_3)
+# endif
+L(return_neq0):
 	/* NB: eax must be zero to reach here.  */
 	ret
 
-	/* NB: aligning 32 here allows for the rest of the jump targets
-	   to be tuned for 32 byte alignment. Most important this ensures
-	   the L(more_8x_vec) loop is 32 byte aligned.  */
+	/* NB: aligning 32 here allows for the rest of the jump
+	   targets to be tuned for 32 byte alignment. Most important
+	   this ensures the L(more_8x_vec) loop is 32 byte aligned.
+	 */
 	.p2align 5
 L(less_vec):
-	/* Check if one or less CHAR. This is necessary for size = 0 but
-	   is also faster for size = CHAR_SIZE.  */
+	/* Check if one or less CHAR. This is necessary for size =
+	   0 but is also faster for size = CHAR_SIZE.  */
 	cmpl	$1, %edx
 	jbe	L(one_or_less)
 
-	/* Check if loading one VEC from either s1 or s2 could cause a
-	   page cross. This can have false positives but is by far the
-	   fastest method.  */
+	/* Check if loading one VEC from either s1 or s2 could
+	   cause a page cross. This can have false positives but is
+	   by far the fastest method.  */
 	movl	%edi, %eax
 	orl	%esi, %eax
 	andl	$(PAGE_SIZE - 1), %eax
@@ -186,66 +224,107 @@ L(less_vec):
 	VMOVU	(%rsi), %YMM2
 	VPCMP	$4, (%rdi), %YMM2, %k1
 	kmovd	%k1, %eax
-	/* Create mask in ecx for potentially in bound matches.  */
+	/* Create mask in ecx for potentially in bound matches.
+	 */
 	bzhil	%edx, %eax, %eax
+# ifndef USE_AS_BCMP
 	jnz	L(return_vec_0)
+# endif
 	ret
+# ifdef USE_AS_BCMP
+	.p2align 4,, 8
+#  ifdef USE_AS_WMEMCMP
+L(one_or_less):
+	jb	L(zero)
+	movl	(%rdi), %eax
+	subl	(%rsi), %eax
+	/* No ymm register was touched.  */
+	ret
+#  else
 
-	.p2align 4
+
+L(one_or_less):
+	jb	L(zero)
+	movzbl	(%rsi), %ecx
+	movzbl	(%rdi), %eax
+	subl	%ecx, %eax
+	/* No ymm register was touched.  */
+	ret
+#  endif
+L(zero):
+	xorl	%eax, %eax
+	ret
+	.p2align 4,, 8
+L(last_2x_vec):
+	/* Check second to last VEC.  */
+	VMOVU	-(VEC_SIZE * 2)(%rsi, %rdx, CHAR_SIZE), %YMM1
+	VPCMP	$4, -(VEC_SIZE * 2)(%rdi, %rdx, CHAR_SIZE), %YMM1, %k1
+	kmovd	%k1, %eax
+	testl	%eax, %eax
+	jnz	L(return_neq1)
+
+	/* Check last VEC.  */
+L(last_1x_vec):
+	VMOVU	-(VEC_SIZE * 1)(%rsi, %rdx, CHAR_SIZE), %YMM1
+	VPCMP	$4, -(VEC_SIZE * 1)(%rdi, %rdx, CHAR_SIZE), %YMM1, %k1
+	kmovd	%k1, %eax
+L(return_neq1):
+	ret
+# else
+	.p2align 4,, 8
 L(return_vec_0):
 	tzcntl	%eax, %eax
-# ifdef USE_AS_WMEMCMP
+#  ifdef USE_AS_WMEMCMP
 	movl	(%rdi, %rax, CHAR_SIZE), %ecx
 	xorl	%edx, %edx
 	cmpl	(%rsi, %rax, CHAR_SIZE), %ecx
-	/* NB: no partial register stall here because xorl zero idiom
-	   above.  */
+	/* NB: no partial register stall here because xorl zero
+	   idiom above.  */
 	setg	%dl
 	leal	-1(%rdx, %rdx), %eax
-# else
+#  else
 	movzbl	(%rsi, %rax), %ecx
 	movzbl	(%rdi, %rax), %eax
 	subl	%ecx, %eax
-# endif
+#  endif
 	ret
 
-	/* NB: No p2align necessary. Alignment  % 16 is naturally 1
-	   which is good enough for a target not in a loop.  */
+	.p2align 4,, 8
 L(return_vec_1):
 	tzcntl	%eax, %eax
-# ifdef USE_AS_WMEMCMP
+#  ifdef USE_AS_WMEMCMP
 	movl	VEC_SIZE(%rdi, %rax, CHAR_SIZE), %ecx
 	xorl	%edx, %edx
 	cmpl	VEC_SIZE(%rsi, %rax, CHAR_SIZE), %ecx
 	setg	%dl
 	leal	-1(%rdx, %rdx), %eax
-# else
+#  else
 	movzbl	VEC_SIZE(%rsi, %rax), %ecx
 	movzbl	VEC_SIZE(%rdi, %rax), %eax
 	subl	%ecx, %eax
-# endif
+#  endif
 	ret
 
-	/* NB: No p2align necessary. Alignment  % 16 is naturally 2
-	   which is good enough for a target not in a loop.  */
+	.p2align 4,, 8
 L(return_vec_2):
 	tzcntl	%eax, %eax
-# ifdef USE_AS_WMEMCMP
+#  ifdef USE_AS_WMEMCMP
 	movl	(VEC_SIZE * 2)(%rdi, %rax, CHAR_SIZE), %ecx
 	xorl	%edx, %edx
 	cmpl	(VEC_SIZE * 2)(%rsi, %rax, CHAR_SIZE), %ecx
 	setg	%dl
 	leal	-1(%rdx, %rdx), %eax
-# else
+#  else
 	movzbl	(VEC_SIZE * 2)(%rsi, %rax), %ecx
 	movzbl	(VEC_SIZE * 2)(%rdi, %rax), %eax
 	subl	%ecx, %eax
-# endif
+#  endif
 	ret
 
-	.p2align 4
+	.p2align 4,, 8
 L(8x_return_vec_0_1_2_3):
-	/* Returning from L(more_8x_vec) requires restoring rsi.  */
+	/* Returning from L(more_8x_vec) requires restoring rsi.
+	 */
 	addq	%rdi, %rsi
 L(return_vec_0_1_2_3):
 	VPCMP	$4, %YMM1, %YMM0, %k0
@@ -264,18 +343,20 @@ L(return_vec_0_1_2_3):
 	jnz	L(return_vec_2)
 L(return_vec_3):
 	tzcntl	%ecx, %ecx
-# ifdef USE_AS_WMEMCMP
+#  ifdef USE_AS_WMEMCMP
 	movl	(VEC_SIZE * 3)(%rdi, %rcx, CHAR_SIZE), %eax
 	xorl	%edx, %edx
 	cmpl	(VEC_SIZE * 3)(%rsi, %rcx, CHAR_SIZE), %eax
 	setg	%dl
 	leal	-1(%rdx, %rdx), %eax
-# else
+#  else
 	movzbl	(VEC_SIZE * 3)(%rdi, %rcx), %eax
 	movzbl	(VEC_SIZE * 3)(%rsi, %rcx), %ecx
 	subl	%ecx, %eax
-# endif
+#  endif
 	ret
+# endif
+
 
 	.p2align 4
 L(more_8x_vec):
@@ -288,7 +369,7 @@ L(more_8x_vec):
 	andq	$-VEC_SIZE, %rdi
 	/* Adjust because first 4x vec where check already.  */
 	subq	$-(VEC_SIZE * 4), %rdi
-	.p2align 4
+	.p2align 4,, 8
 L(loop_4x_vec):
 	VMOVU	(%rsi, %rdi), %YMM1
 	vpxorq	(%rdi), %YMM1, %YMM1
@@ -303,25 +384,41 @@ L(loop_4x_vec):
 	VMOVU	(VEC_SIZE * 3)(%rsi, %rdi), %YMM4
 	vpternlogd $0xde, (VEC_SIZE * 3)(%rdi), %YMM3, %YMM4
 	VPCMP	$4, %YMM4, %YMM0, %k1
-	kmovd	%k1, %ecx
-	testl	%ecx, %ecx
+	kmovd	%k1, %TEST_REG
+	testl	%TEST_REG, %TEST_REG
+# ifdef USE_AS_BCMP
+	jnz	L(return_neq2)
+# else
 	jnz	L(8x_return_vec_0_1_2_3)
+# endif
 	subq	$-(VEC_SIZE * 4), %rdi
 	cmpq	%rdx, %rdi
 	jb	L(loop_4x_vec)
 
 	subq	%rdx, %rdi
+# ifdef USE_AS_BCMP
+	VMOVU	(VEC_SIZE * 3)(%rsi, %rdx), %YMM4
+	vpxorq	(VEC_SIZE * 3)(%rdx), %YMM4, %YMM4
+# endif
 	/* rdi has 4 * VEC_SIZE - remaining length.  */
 	cmpl	$(VEC_SIZE * 3), %edi
 	jae	L(8x_last_1x_vec)
 	/* Load regardless of branch.  */
 	VMOVU	(VEC_SIZE * 2)(%rsi, %rdx), %YMM3
+# ifdef USE_AS_BCMP
+	vpternlogd $0xf6, (VEC_SIZE * 2)(%rdx), %YMM3, %YMM4
+# endif
 	cmpl	$(VEC_SIZE * 2), %edi
 	jae	L(8x_last_2x_vec)
+# ifdef USE_AS_BCMP
+	VMOVU	VEC_SIZE(%rsi, %rdx), %YMM2
+	vpxorq	VEC_SIZE(%rdx), %YMM2, %YMM2
+# endif
 
 	VMOVU	(%rsi, %rdx), %YMM1
 	vpxorq	(%rdx), %YMM1, %YMM1
 
+# ifndef USE_AS_BCMP
 	VMOVU	VEC_SIZE(%rsi, %rdx), %YMM2
 	vpxorq	VEC_SIZE(%rdx), %YMM2, %YMM2
 
@@ -330,17 +427,26 @@ L(loop_4x_vec):
 
 	VMOVU	(VEC_SIZE * 3)(%rsi, %rdx), %YMM4
 	vpternlogd $0xde, (VEC_SIZE * 3)(%rdx), %YMM3, %YMM4
+# else
+	vpternlogd $0xfe, %YMM1, %YMM2, %YMM4
+L(8x_last_1x_vec):
+L(8x_last_2x_vec):
+# endif
+
 	VPCMP	$4, %YMM4, %YMM0, %k1
-	kmovd	%k1, %ecx
+	kmovd	%k1, %TEST_REG
 	/* Restore s1 pointer to rdi.  */
+# ifndef USE_AS_BCMP
 	movq	%rdx, %rdi
 	testl	%ecx, %ecx
 	jnz	L(8x_return_vec_0_1_2_3)
+# endif
 	/* NB: eax must be zero to reach here.  */
+L(return_neq2):
 	ret
-
+# ifndef USE_AS_BCMP
 	/* Only entry is from L(more_8x_vec).  */
-	.p2align 4
+	.p2align 4,, 8
 L(8x_last_2x_vec):
 	VPCMP	$4, (VEC_SIZE * 2)(%rdx), %YMM3, %k1
 	kmovd	%k1, %eax
@@ -355,7 +461,7 @@ L(8x_last_1x_vec):
 	jnz	L(8x_return_vec_3)
 	ret
 
-	.p2align 4
+	.p2align 4,, 8
 L(last_2x_vec):
 	/* Check second to last VEC.  */
 	VMOVU	-(VEC_SIZE * 2)(%rsi, %rdx, CHAR_SIZE), %YMM1
@@ -365,7 +471,7 @@ L(last_2x_vec):
 	jnz	L(return_vec_1_end)
 
 	/* Check last VEC.  */
-	.p2align 4
+	.p2align 4,, 8
 L(last_1x_vec):
 	VMOVU	-(VEC_SIZE * 1)(%rsi, %rdx, CHAR_SIZE), %YMM1
 	VPCMP	$4, -(VEC_SIZE * 1)(%rdi, %rdx, CHAR_SIZE), %YMM1, %k1
@@ -374,96 +480,111 @@ L(last_1x_vec):
 	jnz	L(return_vec_0_end)
 	ret
 
-	.p2align 4
+	.p2align 4,, 8
 L(8x_return_vec_2):
 	subq	$VEC_SIZE, %rdx
 L(8x_return_vec_3):
 	tzcntl	%eax, %eax
-# ifdef USE_AS_WMEMCMP
+#  ifdef USE_AS_WMEMCMP
 	leaq	(%rdx, %rax, CHAR_SIZE), %rax
 	movl	(VEC_SIZE * 3)(%rax), %ecx
 	xorl	%edx, %edx
 	cmpl	(VEC_SIZE * 3)(%rsi, %rax), %ecx
 	setg	%dl
 	leal	-1(%rdx, %rdx), %eax
-# else
+#  else
 	addq	%rdx, %rax
 	movzbl	(VEC_SIZE * 3)(%rsi, %rax), %ecx
 	movzbl	(VEC_SIZE * 3)(%rax), %eax
 	subl	%ecx, %eax
-# endif
+#  endif
 	ret
 
-	.p2align 4
+	.p2align 4,, 8
 L(return_vec_0_end):
 	tzcntl	%eax, %eax
 	addl	%edx, %eax
-# ifdef USE_AS_WMEMCMP
+#  ifdef USE_AS_WMEMCMP
 	movl	-VEC_SIZE(%rdi, %rax, CHAR_SIZE), %ecx
 	xorl	%edx, %edx
 	cmpl	-VEC_SIZE(%rsi, %rax, CHAR_SIZE), %ecx
 	setg	%dl
 	leal	-1(%rdx, %rdx), %eax
-# else
+#  else
 	movzbl	-VEC_SIZE(%rsi, %rax), %ecx
 	movzbl	-VEC_SIZE(%rdi, %rax), %eax
 	subl	%ecx, %eax
-# endif
+#  endif
 	ret
 
-	.p2align 4
+	.p2align 4,, 8
 L(return_vec_1_end):
 	tzcntl	%eax, %eax
 	addl	%edx, %eax
-# ifdef USE_AS_WMEMCMP
+#  ifdef USE_AS_WMEMCMP
 	movl	-(VEC_SIZE * 2)(%rdi, %rax, CHAR_SIZE), %ecx
 	xorl	%edx, %edx
 	cmpl	-(VEC_SIZE * 2)(%rsi, %rax, CHAR_SIZE), %ecx
 	setg	%dl
 	leal	-1(%rdx, %rdx), %eax
-# else
+#  else
 	movzbl	-(VEC_SIZE * 2)(%rsi, %rax), %ecx
 	movzbl	-(VEC_SIZE * 2)(%rdi, %rax), %eax
 	subl	%ecx, %eax
-# endif
+#  endif
 	ret
-
+# endif
 
 	.p2align 4
 L(page_cross_less_vec):
-	/* if USE_AS_WMEMCMP it can only be 0, 4, 8, 12, 16, 20, 24, 28
-	   bytes.  */
+	/* if USE_AS_WMEMCMP it can only be 0, 4, 8, 12, 16, 20,
+	   24, 28 bytes.  */
 	cmpl	$(16 / CHAR_SIZE), %edx
 	jae	L(between_16_31)
 # ifndef USE_AS_WMEMCMP
 	cmpl	$8, %edx
 	jae	L(between_8_15)
 	cmpl	$4, %edx
-	jae	L(between_4_7)
-L(between_2_3):
-	/* Load as big endian to avoid branches.  */
-	movzwl	(%rdi), %eax
-	movzwl	(%rsi), %ecx
-	shll	$8, %eax
-	shll	$8, %ecx
-	bswap	%eax
-	bswap	%ecx
-	movzbl	-1(%rdi, %rdx), %edi
-	movzbl	-1(%rsi, %rdx), %esi
-	orl	%edi, %eax
-	orl	%esi, %ecx
-	/* Subtraction is okay because the upper 8 bits are zero.  */
+	jb	L(between_2_3)
+#  ifdef USE_AS_BCMP
+	movl	(%rdi), %eax
+	movl	(%rsi), %ecx
+	subl	%ecx, %eax
+	jnz	L(return_neq3)
+	movl	-4(%rdi, %rdx), %ecx
+	movl	-4(%rsi, %rdx), %eax
 	subl	%ecx, %eax
+L(return_neq3):
 	ret
-	.p2align 4
+#  else
+	/* Load as big endian with overlapping movbe to avoid
+	   branches.  */
+	movbe	(%rdi), %eax
+	movbe	(%rsi), %ecx
+	shlq	$32, %rax
+	shlq	$32, %rcx
+	movbe	-4(%rdi, %rdx), %edi
+	movbe	-4(%rsi, %rdx), %esi
+	orq	%rdi, %rax
+	orq	%rsi, %rcx
+	subq	%rcx, %rax
+	jz	L(zero_4_7)
+	sbbl	%eax, %eax
+	orl	$1, %eax
+L(zero_4_7):
+	ret
+
+
+	.p2align 4,, 8
 L(one_or_less):
 	jb	L(zero)
 	movzbl	(%rsi), %ecx
 	movzbl	(%rdi), %eax
 	subl	%ecx, %eax
 	ret
+#  endif
 
-	.p2align 4
+	.p2align 4,, 8
 L(between_8_15):
 # endif
 	/* If USE_AS_WMEMCMP fall through into 8-15 byte case.  */
@@ -472,45 +593,67 @@ L(between_8_15):
 	VPCMP	$4, %XMM1, %XMM2, %k1
 	kmovd	%k1, %eax
 	testl	%eax, %eax
+# ifdef USE_AS_BCMP
+	jnz	L(return_neq4)
+	vmovq	-8(%rdi, %rdx, CHAR_SIZE), %XMM1
+	vmovq	-8(%rsi, %rdx, CHAR_SIZE), %XMM2
+# else
 	jnz	L(return_vec_0)
+
 	/* Use overlapping loads to avoid branches.  */
 	leaq	-8(%rdi, %rdx, CHAR_SIZE), %rdi
 	leaq	-8(%rsi, %rdx, CHAR_SIZE), %rsi
 	vmovq	(%rdi), %XMM1
 	vmovq	(%rsi), %XMM2
+# endif
 	VPCMP	$4, %XMM1, %XMM2, %k1
 	kmovd	%k1, %eax
+# ifndef USE_AS_BCMP
 	testl	%eax, %eax
 	jnz	L(return_vec_0)
+# endif
+L(return_neq4):
 	ret
-
+# ifndef USE_AS_BCMP
 	.p2align 4
 L(zero):
 	xorl	%eax, %eax
 	ret
+# endif
 
-	.p2align 4
+	.p2align 4,, 8
 L(between_16_31):
 	/* From 16 to 31 bytes.  No branch when size == 16.  */
 	VMOVU	(%rsi), %XMM2
 	VPCMP	$4, (%rdi), %XMM2, %k1
 	kmovd	%k1, %eax
 	testl	%eax, %eax
+# ifdef USE_AS_BCMP
+	jnz	L(return_neq5)
+# else
 	jnz	L(return_vec_0)
-
+# endif
 	/* Use overlapping loads to avoid branches.  */
 
 	VMOVU	-16(%rsi, %rdx, CHAR_SIZE), %XMM2
+# ifdef USE_AS_BCMP
+	VPCMP	$4, -16(%rdi, %rdx, CHAR_SIZE), %XMM2, %k1
+# else
 	leaq	-16(%rdi, %rdx, CHAR_SIZE), %rdi
 	leaq	-16(%rsi, %rdx, CHAR_SIZE), %rsi
 	VPCMP	$4, (%rdi), %XMM2, %k1
+# endif
 	kmovd	%k1, %eax
+# ifndef USE_AS_BCMP
 	testl	%eax, %eax
 	jnz	L(return_vec_0)
+# endif
+L(return_neq5):
 	ret
 
 # ifdef USE_AS_WMEMCMP
-	.p2align 4
+#  ifndef USE_AS_BCMP
+	.p2align 4,, 8
 L(one_or_less):
 	jb	L(zero)
 	movl	(%rdi), %ecx
@@ -520,25 +663,27 @@ L(one_or_less):
 	setg	%dl
 	leal	-1(%rdx, %rdx), %eax
 	ret
+#  endif
 # else
 
-	.p2align 4
-L(between_4_7):
-	/* Load as big endian with overlapping movbe to avoid branches.
+	.p2align 4,, 8
+L(between_2_3):
+	/* Load as big endian to avoid branches.  */
+	movzwl	(%rdi), %eax
+	movzwl	(%rsi), %ecx
+	shll	$8, %eax
+	shll	$8, %ecx
+#  ifndef USE_AS_BCMP
+	bswap	%eax
+	bswap	%ecx
+#  endif
+	movzbl	-1(%rdi, %rdx), %edi
+	movzbl	-1(%rsi, %rdx), %esi
+	orl	%edi, %eax
+	orl	%esi, %ecx
+	/* Subtraction is okay because the upper 8 bits are zero.
 	 */
-	movbe	(%rdi), %eax
-	movbe	(%rsi), %ecx
-	shlq	$32, %rax
-	shlq	$32, %rcx
-	movbe	-4(%rdi, %rdx), %edi
-	movbe	-4(%rsi, %rdx), %esi
-	orq	%rdi, %rax
-	orq	%rsi, %rcx
-	subq	%rcx, %rax
-	jz	L(zero_4_7)
-	sbbl	%eax, %eax
-	orl	$1, %eax
-L(zero_4_7):
+	subl	%ecx, %eax
 	ret
 # endif
 
-- 
2.25.1

