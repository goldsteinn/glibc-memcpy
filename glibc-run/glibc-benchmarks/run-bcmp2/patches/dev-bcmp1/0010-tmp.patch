From a6d9e0ff3b4e0af2cea3f96a4d05d891876782e4 Mon Sep 17 00:00:00 2001
From: Noah Goldstein <goldstein.w.n@gmail.com>
Date: Mon, 4 Oct 2021 13:25:16 -0500
Subject: [PATCH 10/10] tmp

---
 sysdeps/x86_64/multiarch/bcmp-avx2.S | 237 +++++++++++++--------------
 sysdeps/x86_64/multiarch/bcmp-evex.S | 149 ++++++++---------
 2 files changed, 184 insertions(+), 202 deletions(-)

diff --git a/sysdeps/x86_64/multiarch/bcmp-avx2.S b/sysdeps/x86_64/multiarch/bcmp-avx2.S
index 280f2546fe..0601a77141 100644
--- a/sysdeps/x86_64/multiarch/bcmp-avx2.S
+++ b/sysdeps/x86_64/multiarch/bcmp-avx2.S
@@ -67,80 +67,27 @@ ENTRY (BCMP)
 	vpmovmskb %ymm1, %eax
 	incl	%eax
 	jnz	L(return_neq0)
-	cmpq	$(VEC_SIZE * 2), %rdx
-	jbe	L(last_1x_vec)
-
-	/* Check second VEC no matter what.  */
-	vmovdqu	VEC_SIZE(%rsi), %ymm2
-	VPCMPEQ	VEC_SIZE(%rdi), %ymm2, %ymm2
-	vpmovmskb %ymm2, %eax
-	/* If all 4 VEC where equal eax will be all 1s so incl will overflow
-	   and set zero flag.  */
-	incl	%eax
-	jnz	L(return_neq0)
-
-	/* Less than 4 * VEC.  */
-	cmpq	$(VEC_SIZE * 4), %rdx
-	jbe	L(last_2x_vec)
-
-	/* Check third and fourth VEC no matter what.  */
-	vmovdqu	(VEC_SIZE * 2)(%rsi), %ymm3
-	VPCMPEQ	(VEC_SIZE * 2)(%rdi), %ymm3, %ymm3
-	vpmovmskb %ymm3, %eax
-	incl	%eax
-	jnz	L(return_neq0)
-
-	vmovdqu	(VEC_SIZE * 3)(%rsi), %ymm4
-	VPCMPEQ	(VEC_SIZE * 3)(%rdi), %ymm4, %ymm4
-	vpmovmskb %ymm4, %eax
-	incl	%eax
-	jnz	L(return_neq0)
-
-	/* Go to 4x VEC loop.  */
-	cmpq	$(VEC_SIZE * 8), %rdx
-	ja	L(more_8x_vec)
-
-	/* Handle remainder of size = 4 * VEC + 1 to 8 * VEC without any
-	   branches.  */
+	subq	$(VEC_SIZE * 2), %rdx
+	ja	L(more_2x_vec)
 
-	/* Adjust rsi and rdi to avoid indexed address mode. This end up
-	   saving a 16 bytes of code, prevents unlamination, and bottlenecks in
-	   the AGU.  */
-	addq	%rdx, %rsi
-	vmovdqu	-(VEC_SIZE * 4)(%rsi), %ymm1
-	vmovdqu	-(VEC_SIZE * 3)(%rsi), %ymm2
-	addq	%rdx, %rdi
-
-	VPCMPEQ	-(VEC_SIZE * 4)(%rdi), %ymm1, %ymm1
-	VPCMPEQ	-(VEC_SIZE * 3)(%rdi), %ymm2, %ymm2
-
-	vmovdqu	-(VEC_SIZE * 2)(%rsi), %ymm3
-	VPCMPEQ	-(VEC_SIZE * 2)(%rdi), %ymm3, %ymm3
-	vmovdqu	-VEC_SIZE(%rsi), %ymm4
-	VPCMPEQ	-VEC_SIZE(%rdi), %ymm4, %ymm4
-
-	/* Reduce VEC0 - VEC4.  */
-	vpand	%ymm1, %ymm2, %ymm2
-	vpand	%ymm3, %ymm4, %ymm4
-	vpand	%ymm2, %ymm4, %ymm4
-	vpmovmskb %ymm4, %eax
+	vmovdqu	(VEC_SIZE * 1)(%rsi, %rdx), %ymm1
+	VPCMPEQ	(VEC_SIZE * 1)(%rdi, %rdx), %ymm1, %ymm1
+	vpmovmskb %ymm1, %eax
 	incl	%eax
 L(return_neq0):
-L(return_vzeroupper):
-	ZERO_UPPER_VEC_REGISTERS_RETURN
-
-	/* NB: p2align 5 here will ensure the L(loop_4x_vec) is also 32 byte
-	   aligned.  */
+	VZEROUPPER_RETURN
+	/* NB: p2align 5 here will ensure the L(loop_4x_vec) is also 32
+	   byte aligned.  */
 	.p2align 5
 L(less_vec):
-	/* Check if one or less char. This is necessary for size = 0 but is
-	   also faster for size = 1.  */
+	/* Check if one or less char. This is necessary for size = 0 but
+	   is also faster for size = 1.  */
 	cmpl	$1, %edx
 	jbe	L(one_or_less)
 
-	/* Check if loading one VEC from either s1 or s2 could cause a page
-	   cross. This can have false positives but is by far the fastest
-	   method.  */
+	/* Check if loading one VEC from either s1 or s2 could cause a
+	   page cross. This can have false positives but is by far the
+	   fastest method.  */
 	movl	%edi, %eax
 	orl	%esi, %eax
 	andl	$(PAGE_SIZE - 1), %eax
@@ -152,13 +99,13 @@ L(less_vec):
 	VPCMPEQ	(%rdi), %ymm2, %ymm2
 	vpmovmskb %ymm2, %eax
 	incl	%eax
-	/* Result will be zero if s1 and s2 match. Otherwise first set bit
-	   will be first mismatch.  */
+	/* Result will be zero if s1 and s2 match. Otherwise first set
+	   bit will be first mismatch.  */
 	bzhil	%edx, %eax, %eax
 	VZEROUPPER_RETURN
 
-	/* Relatively cold but placing close to L(less_vec) for 2 byte jump
-	   encoding.  */
+	/* Relatively cold but placing close to L(less_vec) for 2 byte
+	   jump encoding.  */
 	.p2align 4
 L(one_or_less):
 	jb	L(zero)
@@ -173,30 +120,70 @@ L(zero):
 	ret
 
 	.p2align 4
-L(last_1x_vec):
-	vmovdqu	-(VEC_SIZE * 1)(%rsi, %rdx), %ymm1
-	VPCMPEQ	-(VEC_SIZE * 1)(%rdi, %rdx), %ymm1, %ymm1
-	vpmovmskb %ymm1, %eax
+L(more_2x_vec):
+	/* Check second VEC no matter what.  */
+	vmovdqu	VEC_SIZE(%rsi), %ymm2
+	VPCMPEQ	VEC_SIZE(%rdi), %ymm2, %ymm2
+	vpmovmskb %ymm2, %eax
+	/* If all 4 VEC where equal eax will be all 1s so incl will
+	   overflow and set zero flag.  */
 	incl	%eax
-	VZEROUPPER_RETURN
+	jnz	L(return_neq0)
 
-	.p2align 4
-L(last_2x_vec):
+	/* Less than 4 * VEC.  */
+	leaq	(%rdi, %rdx), %rcx
+	cmpq	$(VEC_SIZE * 2), %rdx
+	jbe	L(last_2x_vec)
+
+	/* Check third and fourth VEC no matter what.  */
+	vmovdqu	(VEC_SIZE * 2)(%rsi), %ymm3
+	VPCMPEQ	(VEC_SIZE * 2)(%rdi), %ymm3, %ymm3
+	vpmovmskb %ymm3, %eax
+	incl	%eax
+	jnz	L(return_neq0)
+
+	vmovdqu	(VEC_SIZE * 3)(%rsi), %ymm4
+	VPCMPEQ	(VEC_SIZE * 3)(%rdi), %ymm4, %ymm4
+	vpmovmskb %ymm4, %eax
+	incl	%eax
+	jnz	L(return_neq1)
+
+	/* Go to 4x VEC loop.  */
+	cmpq	$(VEC_SIZE * 6), %rdx
+	ja	L(more_8x_vec)
+
+	/* Handle remainder of size = 4 * VEC + 1 to 8 * VEC without any
+	   branches.  */
+
+	/* Adjust rsi and rdi to avoid indexed address mode. This end up
+	   saving a 16 bytes of code, prevents unlamination, and
+	   bottlenecks in the AGU.  */
 	vmovdqu	-(VEC_SIZE * 2)(%rsi, %rdx), %ymm1
-	VPCMPEQ	-(VEC_SIZE * 2)(%rdi, %rdx), %ymm1, %ymm1
+	VPCMPEQ	-(VEC_SIZE * 2)(%rcx), %ymm1, %ymm1
 	vmovdqu	-(VEC_SIZE * 1)(%rsi, %rdx), %ymm2
-	VPCMPEQ	-(VEC_SIZE * 1)(%rdi, %rdx), %ymm2, %ymm2
+	VPCMPEQ	-(VEC_SIZE * 1)(%rcx), %ymm2, %ymm2
 	vpand	%ymm1, %ymm2, %ymm2
 	vpmovmskb %ymm2, %eax
 	incl	%eax
-	VZEROUPPER_RETURN
+	jnz	L(return_neq1)
+L(last_2x_vec):
+	vmovdqu	-(VEC_SIZE * 0)(%rsi, %rdx), %ymm1
+	VPCMPEQ	-(VEC_SIZE * 0)(%rcx), %ymm1, %ymm1
+	vmovdqu	VEC_SIZE(%rsi, %rdx), %ymm2
+	VPCMPEQ	VEC_SIZE(%rcx), %ymm2, %ymm2
+	vpand	%ymm1, %ymm2, %ymm2
+	vpmovmskb %ymm2, %eax
+	incl	%eax
+L(return_neq1):
+L(return_vzeroupper):
+	ZERO_UPPER_VEC_REGISTERS_RETURN
 
 	.p2align 4
 L(more_8x_vec):
 	/* Set end of s1 in rdx.  */
-	leaq	-(VEC_SIZE * 4)(%rdi, %rdx), %rdx
-	/* rsi stores s2 - s1. This allows loop to only update one pointer.
-	 */
+	addq	$-(VEC_SIZE * 2), %rcx
+	/* rsi stores s2 - s1. This allows loop to only update one
+	   pointer.  */
 	subq	%rdi, %rsi
 	/* Align s1 pointer.  */
 	andq	$-VEC_SIZE, %rdi
@@ -204,7 +191,8 @@ L(more_8x_vec):
 	subq	$-(VEC_SIZE * 4), %rdi
 	.p2align 4
 L(loop_4x_vec):
-	/* rsi has s2 - s1 so get correct address by adding s1 (in rdi).  */
+	/* rsi has s2 - s1 so get correct address by adding s1 (in rdi).
+	 */
 	vmovdqu	(%rsi, %rdi), %ymm1
 	VPCMPEQ	(%rdi), %ymm1, %ymm1
 
@@ -222,29 +210,29 @@ L(loop_4x_vec):
 	vpand	%ymm2, %ymm4, %ymm4
 	vpmovmskb %ymm4, %eax
 	incl	%eax
-	jnz	L(return_neq1)
+	jnz	L(return_neq2)
 	subq	$-(VEC_SIZE * 4), %rdi
 	/* Check if s1 pointer at end.  */
-	cmpq	%rdx, %rdi
+	cmpq	%rcx, %rdi
 	jb	L(loop_4x_vec)
 
-	vmovdqu	(VEC_SIZE * 3)(%rsi, %rdx), %ymm4
-	VPCMPEQ	(VEC_SIZE * 3)(%rdx), %ymm4, %ymm4
-	subq	%rdx, %rdi
+	vmovdqu	(VEC_SIZE * 3)(%rsi, %rcx), %ymm4
+	VPCMPEQ	(VEC_SIZE * 3)(%rcx), %ymm4, %ymm4
+	subq	%rcx, %rdi
 	/* rdi has 4 * VEC_SIZE - remaining length.  */
 	cmpl	$(VEC_SIZE * 3), %edi
 	jae	L(8x_last_1x_vec)
 	/* Load regardless of branch.  */
-	vmovdqu	(VEC_SIZE * 2)(%rsi, %rdx), %ymm3
-	VPCMPEQ	(VEC_SIZE * 2)(%rdx), %ymm3, %ymm3
+	vmovdqu	(VEC_SIZE * 2)(%rsi, %rcx), %ymm3
+	VPCMPEQ	(VEC_SIZE * 2)(%rcx), %ymm3, %ymm3
 	cmpl	$(VEC_SIZE * 2), %edi
 	jae	L(8x_last_2x_vec)
 	/* Check last 4 VEC.  */
-	vmovdqu	VEC_SIZE(%rsi, %rdx), %ymm1
-	VPCMPEQ	VEC_SIZE(%rdx), %ymm1, %ymm1
+	vmovdqu	VEC_SIZE(%rsi, %rcx), %ymm1
+	VPCMPEQ	VEC_SIZE(%rcx), %ymm1, %ymm1
 
-	vmovdqu	(%rsi, %rdx), %ymm2
-	VPCMPEQ	(%rdx), %ymm2, %ymm2
+	vmovdqu	(%rsi, %rcx), %ymm2
+	VPCMPEQ	(%rcx), %ymm2, %ymm2
 
 	vpand	%ymm3, %ymm4, %ymm4
 	vpand	%ymm1, %ymm2, %ymm3
@@ -254,9 +242,11 @@ L(8x_last_1x_vec):
 	vpmovmskb %ymm4, %eax
 	/* Restore s1 pointer to rdi.  */
 	incl	%eax
-L(return_neq1):
+L(return_neq2):
 	VZEROUPPER_RETURN
 
+
+
 	/* Relatively cold case as page cross are unexpected.  */
 	.p2align 4
 L(page_cross_less_vec):
@@ -268,54 +258,61 @@ L(page_cross_less_vec):
 	jb	L(between_2_3)
 	/* From 4 to 8 bytes.  No branch when size == 4.  */
 	movl	(%rdi), %eax
-	movl	(%rsi), %ecx
-	subl	%ecx, %eax
+	subl	(%rsi), %eax
 	movl	-4(%rdi, %rdx), %ecx
-	movl	-4(%rsi, %rdx), %esi
-	subl	%esi, %ecx
+	movl	-4(%rsi, %rdx), %edi
+	subl	%edi, %ecx
 	orl	%ecx, %eax
 	ret
 
+	.p2align 4,, 8
+L(between_16_31):
+	/* From 16 to 31 bytes.  No branch when size == 16.  */
+
+	/* Safe to use xmm[0, 15] as no vzeroupper is needed so RTM
+	   safe.  */
+	movups	(%rsi), %xmm1
+	vpcmpeqb (%rdi), %xmm1, %xmm1
+	movups	-16(%rsi, %rdx), %xmm2
+	vpcmpeqb -16(%rdi, %rdx), %xmm2, %xmm2
+	vpand	%xmm1, %xmm2, %xmm2
+	vpmovmskb %xmm2, %eax
+	subl	$0xffff, %eax
+	/* No ymm register was touched.  */
+	ret
+
 	.p2align 4,, 8
 L(between_9_15):
+	/* Safe to use xmm[0, 15] as no vzeroupper is needed so RTM
+	   safe.  */
 	vmovq	(%rdi), %xmm1
 	vmovq	(%rsi), %xmm2
-	VPCMPEQ	%xmm1, %xmm2, %xmm3
+	vpcmpeqb %xmm1, %xmm2, %xmm3
 	vmovq	-8(%rdi, %rdx), %xmm1
 	vmovq	-8(%rsi, %rdx), %xmm2
-	VPCMPEQ	%xmm1, %xmm2, %xmm2
+	vpcmpeqb %xmm1, %xmm2, %xmm2
 	vpand	%xmm2, %xmm3, %xmm3
 	vpmovmskb %xmm3, %eax
 	subl	$0xffff, %eax
 	/* No ymm register was touched.  */
 	ret
 
-	.p2align 4,, 8
-L(between_16_31):
-	/* From 16 to 31 bytes.  No branch when size == 16.  */
-	vmovdqu	(%rsi), %xmm1
-	VPCMPEQ	(%rdi), %xmm1, %xmm1
-	vmovdqu	-16(%rsi, %rdx), %xmm2
-	VPCMPEQ	-16(%rdi, %rdx), %xmm2, %xmm2
-	vpand	%xmm1, %xmm2, %xmm2
-	vpmovmskb %xmm2, %eax
-	subl	$0xffff, %eax
-	/* No ymm register was touched.  */
-	ret
-
-	.p2align 4,, 8
+	/* Don't align. This is cold and aligning here will cause code
+	   to spill into next cache line.  */
 L(between_2_3):
 	/* From 2 to 3 bytes.  No branch when size == 2.  */
 	movzwl	(%rdi), %eax
 	movzwl	(%rsi), %ecx
 	subl	%ecx, %eax
-	movzbl	-1(%rdi, %rdx), %edi
-	movzbl	-1(%rsi, %rdx), %esi
-	subl	%edi, %esi
-	orl	%esi, %eax
+	movzbl	-1(%rdi, %rdx), %ecx
+	/* All machines that support evex will insert a "merging uop"
+	   avoiding any serious partial register stalls.  */
+	subb	-1(%rsi, %rdx), %cl
+	orl	%ecx, %eax
 	/* No ymm register was touched.  */
 	ret
 
+
     .p2align 12
 END (BCMP)
 #endif
diff --git a/sysdeps/x86_64/multiarch/bcmp-evex.S b/sysdeps/x86_64/multiarch/bcmp-evex.S
index 70487a340c..09d81e8d97 100644
--- a/sysdeps/x86_64/multiarch/bcmp-evex.S
+++ b/sysdeps/x86_64/multiarch/bcmp-evex.S
@@ -71,18 +71,26 @@ ENTRY (BCMP)
 	kmovd	%k1, %eax
 	testl	%eax, %eax
 	jnz	L(return_neq0)
-	cmpq	$(VEC_SIZE * 2), %rdx
-	jbe	L(last_1x_vec)
 
+	subq	$(VEC_SIZE * 2), %rdx
+	ja	L(more_2x_vec)
+	VMOVU	-(VEC_SIZE * -1)(%rsi, %rdx), %YMM1
+	VPCMP	$4, -(VEC_SIZE * -1)(%rdi, %rdx), %YMM1, %k1
+	kmovd	%k1, %eax
+L(return_neq0):
+	ret
+
+	.p2align 4
+L(more_2x_vec):
 	/* Check second VEC no matter what.  */
 	VMOVU	VEC_SIZE(%rsi), %YMM2
 	VPCMP	$4, VEC_SIZE(%rdi), %YMM2, %k1
 	kmovd	%k1, %eax
 	testl	%eax, %eax
 	jnz	L(return_neq0)
-
+	leaq	(%rdi, %rdx), %rcx
 	/* Less than 4 * VEC.  */
-	cmpq	$(VEC_SIZE * 4), %rdx
+	cmpq	$(VEC_SIZE * 2), %rdx
 	jbe	L(last_2x_vec)
 
 	/* Check third and fourth VEC no matter what.  */
@@ -99,37 +107,33 @@ ENTRY (BCMP)
 	jnz	L(return_neq0)
 
 	/* Go to 4x VEC loop.  */
-	cmpq	$(VEC_SIZE * 8), %rdx
+	cmpq	$(VEC_SIZE * 6), %rdx
 	ja	L(more_8x_vec)
+	VMOVU	-(VEC_SIZE * 3 + -2 * VEC_SIZE)(%rsi, %rdx), %YMM1
+	vpxorq	-(VEC_SIZE * 3 + -2 * VEC_SIZE)(%rcx), %YMM1, %YMM1
 
-	/* Handle remainder of size = 4 * VEC + 1 to 8 * VEC without any
-	   branches.  */
-
-	VMOVU	-(VEC_SIZE * 4)(%rsi, %rdx), %YMM1
-	VMOVU	-(VEC_SIZE * 3)(%rsi, %rdx), %YMM2
-    addq    %rdx, %rdi
-    vpxorq	-(VEC_SIZE * 4)(%rdi), %YMM1, %YMM1
-	vpternlogd $0xde, -(VEC_SIZE * 3)(%rdi), %YMM1, %YMM2
-
-	VMOVU	-(VEC_SIZE * 2)(%rsi, %rdx), %YMM3
-	vpxorq	-(VEC_SIZE * 2)(%rdi), %YMM3, %YMM3
-	/* Or together YMM1, YMM2, and YMM3 into YMM3.  */
-	VMOVU	-(VEC_SIZE)(%rsi, %rdx), %YMM4
-	vpxorq	-(VEC_SIZE)(%rdi), %YMM4, %YMM4
-
-
-    vpternlogd $0xfe, %YMM2, %YMM3, %YMM4
+	VMOVU	-(VEC_SIZE * 4 + -2 * VEC_SIZE)(%rsi, %rdx), %YMM2
+	vpternlogd $0xde, -(VEC_SIZE * 4 + -2 * VEC_SIZE)(%rcx), %YMM1, %YMM2
+	VPTEST	%YMM2, %YMM2, %k1
+	kmovd	%k1, %eax
+	testl	%eax, %eax
+	jnz	L(return_neq1)
+	.p2align 4,, 6
+L(last_2x_vec):
+	VMOVU	-(VEC_SIZE * 2 + -2 * VEC_SIZE)(%rsi, %rdx), %YMM1
+	vpxorq	-(VEC_SIZE * 2 + -2 * VEC_SIZE)(%rcx), %YMM1, %YMM1
 
-	/* Compare YMM4 with 0. If any 1s s1 and s2 don't match.  */
-	VPTEST	%YMM4, %YMM4, %k1
+	VMOVU	-(VEC_SIZE * 1 + -2 * VEC_SIZE)(%rsi, %rdx), %YMM2
+	vpternlogd $0xde, -(VEC_SIZE * 1 + -2 * VEC_SIZE)(%rcx), %YMM1, %YMM2
+	VPTEST	%YMM2, %YMM2, %k1
 	kmovd	%k1, %eax
-L(return_neq0):
+L(return_neq1):
 	ret
 
 	.p2align 4
 L(more_8x_vec):
 	/* Set end of s1 in rdx.  */
-    leaq    -(VEC_SIZE * 4)(%rdi, %rdx), %rdx
+	addq	$-(VEC_SIZE * 2), %rcx
 	/* rsi stores s2 - s1. This allows loop to only update one
 	   pointer.  */
 	subq	%rdi, %rsi
@@ -143,45 +147,42 @@ L(loop_4x_vec):
 	vpxorq	(%rdi), %YMM1, %YMM1
 
 	VMOVU	VEC_SIZE(%rsi, %rdi), %YMM2
-    vpternlogd $0xde, (VEC_SIZE)(%rdi), %YMM1, %YMM2
-	
+	vpternlogd $0xde, (VEC_SIZE)(%rdi), %YMM1, %YMM2
 
 	VMOVU	(VEC_SIZE * 2)(%rsi, %rdi), %YMM3
 	vpxorq	(VEC_SIZE * 2)(%rdi), %YMM3, %YMM3
 
-
 	VMOVU	(VEC_SIZE * 3)(%rsi, %rdi), %YMM4
 	vpxorq	(VEC_SIZE * 3)(%rdi), %YMM4, %YMM4
 
-    vpternlogd $0xfe, %YMM2, %YMM3, %YMM4
-    
+	vpternlogd $0xfe, %YMM2, %YMM3, %YMM4
 	VPTEST	%YMM4, %YMM4, %k1
 	kmovd	%k1, %eax
 	testl	%eax, %eax
 	jnz	L(return_neq2)
 	subq	$-(VEC_SIZE * 4), %rdi
-	cmpq	%rdx, %rdi
+	cmpq	%rcx, %rdi
 	jb	L(loop_4x_vec)
 
-	subq	%rdx, %rdi
-	VMOVU	(VEC_SIZE * 3)(%rsi, %rdx), %YMM4
-	vpxorq	(VEC_SIZE * 3)(%rdx), %YMM4, %YMM4
+	subq	%rcx, %rdi
+	VMOVU	(VEC_SIZE * 3)(%rsi, %rcx), %YMM4
+	vpxorq	(VEC_SIZE * 3)(%rcx), %YMM4, %YMM4
 	/* rdi has 4 * VEC_SIZE - remaining length.  */
 	cmpl	$(VEC_SIZE * 3), %edi
 	jae	L(8x_last_1x_vec)
 	/* Load regardless of branch.  */
-	VMOVU	(VEC_SIZE * 2)(%rsi, %rdx), %YMM3
-	/* Ternary logic to xor (VEC_SIZE * 2)(%rdx) with YMM3 while
+	VMOVU	(VEC_SIZE * 2)(%rsi, %rcx), %YMM3
+	/* Ternary logic to xor (VEC_SIZE * 2)(%rcx) with YMM3 while
 	   oring with YMM4. Result is stored in YMM4.  */
-	vpternlogd $0xf6, (VEC_SIZE * 2)(%rdx), %YMM3, %YMM4
+	vpternlogd $0xf6, (VEC_SIZE * 2)(%rcx), %YMM3, %YMM4
 	cmpl	$(VEC_SIZE * 2), %edi
 	jae	L(8x_last_2x_vec)
 
-	VMOVU	VEC_SIZE(%rsi, %rdx), %YMM2
-	vpxorq	VEC_SIZE(%rdx), %YMM2, %YMM2
+	VMOVU	VEC_SIZE(%rsi, %rcx), %YMM2
+	vpxorq	VEC_SIZE(%rcx), %YMM2, %YMM2
 
-	VMOVU	(%rsi, %rdx), %YMM1
-	vpxorq	(%rdx), %YMM1, %YMM1
+	VMOVU	(%rsi, %rcx), %YMM1
+	vpxorq	(%rcx), %YMM1, %YMM1
 
 	vpternlogd $0xfe, %YMM1, %YMM2, %YMM4
 L(8x_last_1x_vec):
@@ -191,19 +192,10 @@ L(8x_last_2x_vec):
 L(return_neq2):
 	ret
 
-	.p2align 4
-L(last_2x_vec):
-	VMOVU	-(VEC_SIZE * 2)(%rsi, %rdx), %YMM1
-	vpxorq	-(VEC_SIZE * 2)(%rdi, %rdx), %YMM1, %YMM1
-	VMOVU	-(VEC_SIZE * 1)(%rsi, %rdx), %YMM2
-	vpternlogd $0xde, -(VEC_SIZE * 1)(%rdi, %rdx), %YMM1, %YMM2
-	VPTEST	%YMM2, %YMM2, %k1
-	kmovd	%k1, %eax
-	ret
 
 	/* NB: p2align 5 here will ensure the L(loop_4x_vec) is also 32
 	   byte aligned.  */
-	.p2align 5
+	.p2align 4
 L(less_vec):
 	/* Check if one or less char. This is necessary for size = 0 but
 	   is also faster for size = 1.  */
@@ -244,16 +236,6 @@ L(zero):
 	ret
 
 
-	.p2align 5
-	/* Fits in padding needed to .p2align 5 L(less_vec).  */
-L(last_1x_vec):
-	VMOVU	-(VEC_SIZE * 1)(%rsi, %rdx), %YMM1
-	VPCMP	$4, -(VEC_SIZE * 1)(%rdi, %rdx), %YMM1, %k1
-	kmovd	%k1, %eax
-	ret
-
-
-
 	/* Relatively cold case as page cross are unexpected.  */
 	.p2align 4
 L(page_cross_less_vec):
@@ -272,10 +254,26 @@ L(page_cross_less_vec):
 	orl	%ecx, %eax
 	ret
 
+	.p2align 4,, 8
+L(between_16_31):
+	/* From 16 to 31 bytes.  No branch when size == 16.  */
+
+	/* Safe to use xmm[0, 15] as no vzeroupper is needed so RTM
+	   safe.  */
+	movups	(%rsi), %xmm1
+	vpcmpeqb (%rdi), %xmm1, %xmm1
+	movups	-16(%rsi, %rdx), %xmm2
+	vpcmpeqb -16(%rdi, %rdx), %xmm2, %xmm2
+	vpand	%xmm1, %xmm2, %xmm2
+	vpmovmskb %xmm2, %eax
+	subl	$0xffff, %eax
+	/* No ymm register was touched.  */
+	ret
+
 	.p2align 4,, 8
 L(between_9_15):
-	/* Safe to use xmm[0, 15] as no vzeroupper is needed so RTM safe.
-	 */
+	/* Safe to use xmm[0, 15] as no vzeroupper is needed so RTM
+	   safe.  */
 	vmovq	(%rdi), %xmm1
 	vmovq	(%rsi), %xmm2
 	vpcmpeqb %xmm1, %xmm2, %xmm3
@@ -287,34 +285,21 @@ L(between_9_15):
 	subl	$0xffff, %eax
 	/* No ymm register was touched.  */
 	ret
-    
+
+	/* Don't align. This is cold and aligning here will cause code
+	   to spill into next cache line.  */
 L(between_2_3):
 	/* From 2 to 3 bytes.  No branch when size == 2.  */
 	movzwl	(%rdi), %eax
 	movzwl	(%rsi), %ecx
 	subl	%ecx, %eax
 	movzbl	-1(%rdi, %rdx), %ecx
+	/* All machines that support evex will insert a "merging uop"
+	   avoiding any serious partial register stalls.  */
 	subb	-1(%rsi, %rdx), %cl
 	orl	%ecx, %eax
 	/* No ymm register was touched.  */
 	ret
-    
-	.p2align 4,, 8
-L(between_16_31):
-	/* From 16 to 31 bytes.  No branch when size == 16.  */
-
-	/* Safe to use xmm[0, 15] as no vzeroupper is needed so RTM safe.
-	 */
-	movups	(%rsi), %xmm1
-	vpcmpeqb (%rdi), %xmm1, %xmm1
-	movups	-16(%rsi, %rdx), %xmm2
-	vpcmpeqb -16(%rdi, %rdx), %xmm2, %xmm2
-	vpand	%xmm1, %xmm2, %xmm2
-	vpmovmskb %xmm2, %eax
-	subl	$0xffff, %eax
-	/* No ymm register was touched.  */
-	ret
-
 
     .p2align 12
 END (BCMP)
-- 
2.25.1

