From cf8d3332e71e5d1d073819643f3b84392775f567 Mon Sep 17 00:00:00 2001
From: Noah Goldstein <goldstein.w.n@gmail.com>
Date: Mon, 23 Aug 2021 01:43:51 -0400
Subject: [PATCH 8/9] benchtests: Add partial overlap case in
 bench-memmove-walk.c

This commit adds a new partial overlap benchmark. This is generally
the most interesting performance case for memmove and was missing.
---
 benchtests/bench-memmove-walk.c | 67 ++++++++++++++++++++++++---------
 1 file changed, 49 insertions(+), 18 deletions(-)

diff --git a/benchtests/bench-memmove-walk.c b/benchtests/bench-memmove-walk.c
index b5fdb2a422..18b716f5cb 100644
--- a/benchtests/bench-memmove-walk.c
+++ b/benchtests/bench-memmove-walk.c
@@ -36,6 +36,10 @@
 # define TIMEOUT (20 * 60)
 # include "bench-string.h"
 
+#define NO_OVERLAP 0
+#define PARTIAL_OVERLAP 1
+#define COMPLETE_OVERLAP 2
+
 IMPL (memmove, 1)
 #endif
 
@@ -66,20 +70,40 @@ do_one_test (json_ctx_t *json_ctx, impl_t *impl, char *dst, char *src,
 }
 
 static void
-do_test (json_ctx_t *json_ctx, size_t len, bool overlap)
+do_test (json_ctx_t *json_ctx, size_t len, int overlap, int both_ways)
 {
-  json_element_object_begin (json_ctx);
-  json_attr_uint (json_ctx, "length", (double) len);
-  json_array_begin (json_ctx, "timings");
-
-  if (overlap)
-    buf2 = buf1;
-
-  FOR_EACH_IMPL (impl, 0)
-    do_one_test (json_ctx, impl, (char *) buf2, (char *) buf1, len);
-
-  json_array_end (json_ctx);
-  json_element_object_end (json_ctx);
+  char *s1, *s2, *tmp;    
+  size_t repeats;
+
+  s1 = (char *) (buf1);
+  s2 = (char *) (buf2);
+  if (overlap != NO_OVERLAP)
+    s2 = s1;
+  if (overlap == PARTIAL_OVERLAP)
+    s2 += len / 2;
+
+  for (repeats = both_ways ? 2 : 1; repeats; --repeats)
+    {    
+      json_element_object_begin (json_ctx);
+      json_attr_uint (json_ctx, "length", (double) len);
+      json_attr_string(json_ctx, "overlap",
+                       overlap == NO_OVERLAP        ? "none"
+                       : overlap == PARTIAL_OVERLAP ? "partial"
+                                                    : "complete");
+      json_attr_uint (json_ctx, "dst > src", (double) (s2 > s1));      
+      json_array_begin (json_ctx, "timings");
+
+
+      FOR_EACH_IMPL (impl, 0)
+        do_one_test (json_ctx, impl, (char *) buf2, (char *) buf1, len);
+
+      json_array_end (json_ctx);
+      json_element_object_end (json_ctx);
+
+      tmp = s1;
+      s1 = s2;
+      s2 = tmp;
+    }
 }
 
 int
@@ -107,15 +131,22 @@ test_main (void)
   /* Non-overlapping buffers.  */
   for (size_t i = START_SIZE; i <= MIN_PAGE_SIZE; i <<= 1)
     {
-      do_test (&json_ctx, i, false);
-      do_test (&json_ctx, i + 1, false);
+      do_test (&json_ctx, i, NO_OVERLAP, 1);
+      do_test (&json_ctx, i + 1, NO_OVERLAP, 1);
+    }
+
+  /* Partially-overlapping buffers.  */
+  for (size_t i = START_SIZE; i <= MIN_PAGE_SIZE / 2; i <<= 1)
+    {
+      do_test (&json_ctx, i, PARTIAL_OVERLAP, 1);
+      do_test (&json_ctx, i + 1, PARTIAL_OVERLAP, 1);
     }
 
-  /* Overlapping buffers.  */
+  /* Complete-overlapping buffers.  */
   for (size_t i = START_SIZE; i <= MIN_PAGE_SIZE; i <<= 1)
     {
-      do_test (&json_ctx, i, true);
-      do_test (&json_ctx, i + 1, true);
+      do_test (&json_ctx, i, COMPLETE_OVERLAP, 0);
+      do_test (&json_ctx, i + 1, COMPLETE_OVERLAP, 0);
     }
 
   json_array_end (&json_ctx);
-- 
2.25.1

