From 61996678a38fdff151f05343610b97bed75063db Mon Sep 17 00:00:00 2001
From: Noah Goldstein <goldstein.w.n@gmail.com>
Date: Mon, 20 Sep 2021 23:54:42 -0500
Subject: [PATCH 11/11] memset 2

---
 .../multiarch/memset-vec-unaligned-erms.S     | 153 ++++++++----------
 1 file changed, 68 insertions(+), 85 deletions(-)

diff --git a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
index 9e778b3628..b5880b4684 100644
--- a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
+++ b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
@@ -65,13 +65,13 @@
 
 #if MOV_SIZE > 5
 #define LARGE_MOV_SIZE (1)
-# define LOOP_4X_OFFSET	(VEC_SIZE	*	4)    
+# define LOOP_4X_OFFSET	(VEC_SIZE	*	4)
 #else
 #define LARGE_MOV_SIZE (0)
 # define LOOP_4X_OFFSET	(0)
 #endif
 #define SMALL_MOV_ALIGN(mov_sz,	ret_sz)	(2	*	(mov_sz)	+	(ret_sz))
-    
+
 #define PAGE_SIZE 4096
 
 #ifndef SECTION
@@ -119,15 +119,13 @@ ENTRY (MEMSET_SYMBOL (__memset, unaligned))
 	mov	%edx, %edx
 # endif
 L(entry_from_bzero):
-    /* Universally useful to have end pointer. */
-	leaq	(%rdi, %rdx), %rcx    
 	cmpq	$VEC_SIZE, %rdx
 	jb	L(less_vec)
 	cmpq	$(VEC_SIZE * 2), %rdx
 	ja	L(more_2x_vec)
 	/* From VEC and to 2 * VEC.  No branch when size == VEC_SIZE.  */
 	VMOVU	%VEC(0), (%rdi)
-    VMOVU	%VEC(0), -VEC_SIZE(%rcx)
+    VMOVU	%VEC(0), -VEC_SIZE(%rdi, %rdx)
 	VZEROUPPER_RETURN
 #if defined USE_MULTIARCH && IS_IN (libc)
 END (MEMSET_SYMBOL (__memset, unaligned))
@@ -176,88 +174,73 @@ ENTRY_P2ALIGN(MEMSET_SYMBOL (__memset, unaligned_erms), 6)
 	/* Clear the upper 32 bits.  */
 	mov	%edx, %edx
 # endif
-    /* Universally useful to have end pointer. */
-	leaq	(%rdi, %rdx), %rcx
 	cmp	$VEC_SIZE, %RDX_LP
 	jb	L(less_vec)
 	cmp	$(VEC_SIZE * 2), %RDX_LP
 	ja	L(stosb_more_2x_vec)
 	/* From VEC and to 2 * VEC.  No branch when size == VEC_SIZE.  */
-	VMOVU	%VEC(0), (%rdi)
-    VMOVU	%VEC(0), -VEC_SIZE(%rcx)
+	VMOVU	%VEC(0), (%rax)
+	VMOVU	%VEC(0), -VEC_SIZE(%rax, %rdx)
 	VZEROUPPER_RETURN
-#if VEC_SIZE == 16
-    .p2align 5
 #endif
-	.p2align 4,,14
+#ifndef LARGE_MOV_SIZE
+	.p2align 5
+#else
+	.p2align 4
+#endif
+#if defined USE_MULTIARCH && IS_IN (libc)
 L(stosb_more_2x_vec):
 	cmp	__x86_rep_stosb_threshold(%rip), %RDX_LP
 	ja	L(stosb)
-#else
-	.p2align 4,,14
 #endif
 L(more_2x_vec):
 	/* Stores to first 2x VEC before cmp as any path forward will
 	   require it.  */
-	VMOVU	%VEC(0), (%rdi)
-	VMOVU	%VEC(0), VEC_SIZE(%rdi)
+	VMOVU	%VEC(0), (%rax)
+	VMOVU	%VEC(0), VEC_SIZE(%rax)
+	leaq	-(VEC_SIZE * 4)(%rax, %rdx), %rcx
 	cmpq	$(VEC_SIZE * 4), %rdx
-	ja	L(loop_start)
-	VMOVU	%VEC(0), -(VEC_SIZE * 2)(%rcx)
-	VMOVU	%VEC(0), -VEC_SIZE(%rcx)
-L(return):
-#if VEC_SIZE > 16
-	ZERO_UPPER_VEC_REGISTERS_RETURN
-    .p2align 4,,13
-#else
-	ret
-#endif
-    .p2align 4,,8
-L(loop_start):
-	VMOVU	%VEC(0), (VEC_SIZE * 2)(%rdi)
-	VMOVU	%VEC(0), (VEC_SIZE * 3)(%rdi)
-#if LARGE_MOV_SIZE
-	subq	$(VEC_SIZE * 8), %rdx
-#else
+	jbe	L(last_2x_vec)
+	VMOVU	%VEC(0), (VEC_SIZE * 2)(%rax)
+	VMOVU	%VEC(0), (VEC_SIZE * 3)(%rax)
 	cmpq	$(VEC_SIZE * 8), %rdx
-#endif
-	jbe	L(loop_end)
+	jbe	L(last_4x_vec)
 	andq	$-(VEC_SIZE * 2), %rdi
-#if LARGE_MOV_SIZE
-    addq    %rax, %rdx
-#else
 	subq	$-(VEC_SIZE * 4), %rdi
-	leaq	-(VEC_SIZE * 4)(%rcx), %rdx
-#endif
+
 	.p2align 4
 L(loop):
-	VMOVA	%VEC(0), (LOOP_4X_OFFSET)(%rdi)
-	VMOVA	%VEC(0), (VEC_SIZE + LOOP_4X_OFFSET)(%rdi)
-	VMOVA	%VEC(0), (VEC_SIZE * 2 + LOOP_4X_OFFSET)(%rdi)
-	VMOVA	%VEC(0), (VEC_SIZE * 3 + LOOP_4X_OFFSET)(%rdi)
+	VMOVA	%VEC(0), (%rdi)
+	VMOVA	%VEC(0), (VEC_SIZE)(%rdi)
+	VMOVA	%VEC(0), (VEC_SIZE * 2)(%rdi)
+	VMOVA	%VEC(0), (VEC_SIZE * 3)(%rdi)
 	subq	$-(VEC_SIZE * 4), %rdi
-	cmpq	%rdx, %rdi
+	cmpq	%rcx, %rdi
 	jb	L(loop)
-L(loop_end):
-	/* NB: rax is set as ptr in MEMSET_VDUP_TO_VEC0_AND_SET_RETURN.
-	       rdx as length is also unchanged.  */
-	VMOVU	%VEC(0), -(VEC_SIZE * 4)(%rcx)
-	VMOVU	%VEC(0), -(VEC_SIZE * 3)(%rcx)
-	VMOVU	%VEC(0), -(VEC_SIZE * 2)(%rcx)
-	VMOVU	%VEC(0), -VEC_SIZE(%rcx)
-	VZEROUPPER_SHORT_RETURN
-
-	.p2align 4,,12
+L(last_4x_vec):
+	/* NB: rax is set as ptr in MEMSET_VDUP_TO_VEC0_AND_SET_RETURN. rdx
+	   as length is also unchanged.  */
+	VMOVU	%VEC(0), (%rcx)
+	VMOVU	%VEC(0), (VEC_SIZE * 1)(%rcx)
+L(last_2x_vec):
+	VMOVU	%VEC(0), (VEC_SIZE * 2)(%rcx)
+	VMOVU	%VEC(0), (VEC_SIZE * 3)(%rcx)
+L(return):    
+#if VEC_SIZE == 16
+	ret
+#else
+	ZERO_UPPER_VEC_REGISTERS_RETURN
+#endif
+	.p2align 4,, 10
 L(less_vec):
 	/* Less than 1 VEC.  */
-# if VEC_SIZE != 16 && VEC_SIZE != 32 && VEC_SIZE != 64
-#  error Unsupported VEC_SIZE!
-# endif
-# ifdef USE_LESS_VEC_MASK_STORE
+#if VEC_SIZE != 16 && VEC_SIZE != 32 && VEC_SIZE != 64
+# error Unsupported VEC_SIZE!
+#endif
+#ifdef USE_LESS_VEC_MASK_STORE
 	/* Clear high bits from edi. Only keeping bits relevant to page
 	   cross check. Note that we are using rax which is set in
-	   MEMSET_VDUP_TO_VEC0_AND_SET_RETURN as ptr from here on out.
-	 */
+	   MEMSET_VDUP_TO_VEC0_AND_SET_RETURN as ptr from here on out.  */
 	andl	$(PAGE_SIZE - 1), %edi
 	/* Check if VEC_SIZE store cross page. Mask stores suffer serious
 	   performance degradation when it has to fault supress.  */
@@ -272,20 +255,20 @@ L(less_vec):
 	bzhil	%edx, %ecx, %ecx
 	kmovd	%ecx, %k1
 # endif
-	vmovdqu8	%VEC(0), (%rax) {%k1}
+	vmovdqu8 %VEC(0), (%rax){%k1}
 	VZEROUPPER_RETURN
 
-	.p2align 4,,12
+	.p2align 4,, 10
 L(cross_page):
-# endif
-# if VEC_SIZE > 32
+#endif
+#if VEC_SIZE > 32
 	cmpl	$32, %edx
 	jae	L(between_32_63)
-# endif
-# if VEC_SIZE > 16
+#endif
+#if VEC_SIZE > 16
 	cmpl	$16, %edx
 	jae	L(between_16_31)
-# endif
+#endif
 	MOVQ	%XMM0, %rdi
 	cmpl	$8, %edx
 	jae	L(between_8_15)
@@ -297,41 +280,41 @@ L(cross_page):
 	movb	%sil, (%rax)
 1:
 	VZEROUPPER_RETURN
-# if VEC_SIZE > 32
-    .p2align 4,, SMALL_MOV_ALIGN(MOV_SIZE, RET_SIZE)
+#if VEC_SIZE > 32
+	.p2align 4,, SMALL_MOV_ALIGN(MOV_SIZE, RET_SIZE)
 	/* From 32 to 63.  No branch when size == 32.  */
 L(between_32_63):
 	VMOVU	%YMM0, (%rax)
-    VMOVU	%YMM0, -32(%rcx)
+	VMOVU	%YMM0, -32(%rax, %rdx)
 	VZEROUPPER_RETURN
-# endif
-# if VEC_SIZE > 16
-     .p2align 4,, SMALL_MOV_ALIGN(MOV_XMM_SIZE, RET_SIZE)
+#endif
+#if VEC_SIZE > 16
+	.p2align 4,, SMALL_MOV_ALIGN(MOV_XMM_SIZE, RET_SIZE)
 L(between_16_31):
-    /* From 16 to 31.  No branch when size == 16.  */
-	VMOVU_XMM	%XMM0, (%rax)
-    VMOVU_XMM	%XMM0, -16(%rcx)
+	/* From 16 to 31.  No branch when size == 16.  */
+	VMOVU_XMM %XMM0, (%rax)
+	VMOVU_XMM %XMM0, -16(%rax, %rdx)
 	VZEROUPPER_RETURN
-# endif
-    .p2align 4,, SMALL_MOV_ALIGN(3, RET_SIZE)
+#endif
+	.p2align 4,, SMALL_MOV_ALIGN(3, RET_SIZE)
 L(between_8_15):
-    /* From 8 to 15.  No branch when size == 8.  */
+	/* From 8 to 15.  No branch when size == 8.  */
 	movq	%rdi, (%rax)
-    movq	%rdi, -8(%rcx)
+	movq	%rdi, -8(%rax, %rdx)
 	VZEROUPPER_RETURN
 
-    .p2align 4,, SMALL_MOV_ALIGN(2, RET_SIZE)
+	.p2align 4,, SMALL_MOV_ALIGN(2, RET_SIZE)
 L(between_4_7):
 	/* From 4 to 7.  No branch when size == 4.  */
 	movl	%edi, (%rax)
-    movl	%edi, -4(%rcx)
+	movl	%edi, -4(%rax, %rdx)
 	VZEROUPPER_RETURN
 
-    .p2align 4,, SMALL_MOV_ALIGN(3, RET_SIZE)
+	.p2align 4,, SMALL_MOV_ALIGN(3, RET_SIZE)
 L(between_2_3):
 	/* From 2 to 3.  No branch when size == 2.  */
 	movw	%di, (%rax)
-    movb	%dil, -1(%rcx)
+	movb	%dil, -1(%rax, %rdx)
 	VZEROUPPER_RETURN
     .p2align 12
 END (MEMSET_SYMBOL (__memset, unaligned_erms))
-- 
2.25.1

