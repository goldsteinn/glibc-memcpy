From 65a5554ad11f38469100cf812f9385d7d63a1fbd Mon Sep 17 00:00:00 2001
From: Noah Goldstein <goldstein.w.n@gmail.com>
Date: Sat, 18 Sep 2021 17:22:12 -0500
Subject: [PATCH 7/8] run3

---
 sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S | 218 +++++++++++--------
 sysdeps/x86_64/multiarch/memcmp-evex-movbe.S |   3 +-
 2 files changed, 124 insertions(+), 97 deletions(-)

diff --git a/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S b/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
index 76cd103182..9211e6c9de 100644
--- a/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
+++ b/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
@@ -149,59 +149,24 @@ ENTRY_P2ALIGN (MEMCMP, 6)
 	/* NB: eax must be zero to reach here.  */
 	VZEROUPPER_RETURN
 
-
 	.p2align 4,, 10
-L(8x_return_vec_0_1_2_3):
-	/* Returning from L(more_8x_vec) requires restoring rsi.  */
-	addq	%rdi, %rsi
-L(return_vec_0_1_2_3):
-	vpmovmskb %ymm1, %eax
-	incl	%eax
-	jnz	L(return_vec_0)
-
-	vpmovmskb %ymm2, %eax
-	incl	%eax
-	jnz	L(return_vec_1)
-
-	vpmovmskb %ymm3, %eax
-	incl	%eax
-	jnz	L(return_vec_2)
-	.p2align 4,, 4
-L(return_vec_3):
-	tzcntl	%ecx, %ecx
-# ifdef USE_AS_WMEMCMP
-	movl	(VEC_SIZE * 3)(%rdi, %rcx), %eax
-	xorl	%edx, %edx
-	cmpl	(VEC_SIZE * 3)(%rsi, %rcx), %eax
-	setg	%dl
-	leal	-1(%rdx, %rdx), %eax
-# else
-	movzbl	(VEC_SIZE * 3)(%rdi, %rcx), %eax
-	movzbl	(VEC_SIZE * 3)(%rsi, %rcx), %ecx
-	subl	%ecx, %eax
-# endif
-L(return_vzeroupper):
-	ZERO_UPPER_VEC_REGISTERS_RETURN
-
-
-	.p2align 4
-L(return_vec_0):
+L(return_vec_2):
 	bsfl	%eax, %eax
 # ifdef USE_AS_WMEMCMP
-	movl	(%rdi, %rax), %ecx
+	movl	(VEC_SIZE * 2)(%rdi, %rax), %ecx
 	xorl	%edx, %edx
-	cmpl	(%rsi, %rax), %ecx
-	/* NB: no partial register stall here because xorl zero idiom above.
-	 */
+	cmpl	(VEC_SIZE * 2)(%rsi, %rax), %ecx
 	setg	%dl
 	leal	-1(%rdx, %rdx), %eax
 # else
-	movzbl	(%rsi, %rax), %ecx
-	movzbl	(%rdi, %rax), %eax
+	movzbl	(VEC_SIZE * 2)(%rsi, %rax), %ecx
+	movzbl	(VEC_SIZE * 2)(%rdi, %rax), %eax
 	subl	%ecx, %eax
 # endif
 	VZEROUPPER_RETURN
 
+
+
 	.p2align 4,, 10
 L(return_vec_1):
 	bsfl	%eax, %eax
@@ -218,74 +183,56 @@ L(return_vec_1):
 # endif
 	VZEROUPPER_RETURN
 
-	.p2align 4,, 9
-L(return_vec_2):
+	.p2align 4
+L(return_vec_0):
 	bsfl	%eax, %eax
 # ifdef USE_AS_WMEMCMP
-	movl	(VEC_SIZE * 2)(%rdi, %rax), %ecx
+	movl	(%rdi, %rax), %ecx
 	xorl	%edx, %edx
-	cmpl	(VEC_SIZE * 2)(%rsi, %rax), %ecx
+	cmpl	(%rsi, %rax), %ecx
+	/* NB: no partial register stall here because xorl zero idiom above.
+	 */
 	setg	%dl
 	leal	-1(%rdx, %rdx), %eax
 # else
-	movzbl	(VEC_SIZE * 2)(%rsi, %rax), %ecx
-	movzbl	(VEC_SIZE * 2)(%rdi, %rax), %eax
+	movzbl	(%rsi, %rax), %ecx
+	movzbl	(%rdi, %rax), %eax
 	subl	%ecx, %eax
 # endif
 	VZEROUPPER_RETURN
 
 	.p2align 4
-L(less_vec):
-	/* Check if one or less CHAR. This is necessary for size = 0 but is
-	   also faster for size = CHAR_SIZE.  */
-	cmpl	$CHAR_SIZE, %edx
-	jbe	L(one_or_less)
-
-	/* Check if loading one VEC from either s1 or s2 could cause a page
-	   cross. This can have false positives but is by far the fastest
-	   method.  */
-	movl	%edi, %eax
-	orl	%esi, %eax
-	andl	$(PAGE_SIZE - 1), %eax
-	cmpl	$(PAGE_SIZE - VEC_SIZE), %eax
-	jg	L(page_cross_less_vec)
+L(8x_return_vec_0_1_2_3):
+	/* Returning from L(more_8x_vec) requires restoring rsi.  */
+	addq	%rdi, %rsi
+L(return_vec_0_1_2_3):
+	vpmovmskb %ymm1, %eax
+	incl	%eax
+	jnz	L(return_vec_0)
 
-	/* No page cross possible.  */
-	vmovdqu	(%rsi), %ymm2
-	VPCMPEQ	(%rdi), %ymm2, %ymm2
 	vpmovmskb %ymm2, %eax
 	incl	%eax
-	/* Result will be zero if s1 and s2 match. Otherwise first set bit
-	   will be first mismatch.  */
-	bzhil	%edx, %eax, %eax
-	jnz	L(return_vec_0)
-	VZEROUPPER_RETURN
+	jnz	L(return_vec_1)
 
-    .p2align 4
+	vpmovmskb %ymm3, %eax
+	incl	%eax
+	jnz	L(return_vec_2)
+	.p2align 4,, 4
+L(return_vec_3):
+	tzcntl	%ecx, %ecx
 # ifdef USE_AS_WMEMCMP
-L(one_or_less):
-	jb	L(zero)
-	movl	(%rdi), %ecx
+	movl	(VEC_SIZE * 3)(%rdi, %rcx), %eax
 	xorl	%edx, %edx
-	cmpl	(%rsi), %ecx
-	je	L(zero)
+	cmpl	(VEC_SIZE * 3)(%rsi, %rcx), %eax
 	setg	%dl
 	leal	-1(%rdx, %rdx), %eax
-	/* No ymm register was touched.  */
-	ret
 # else
-L(one_or_less):
-	jb	L(zero)
-	movzbl	(%rsi), %ecx
-	movzbl	(%rdi), %eax
+	movzbl	(VEC_SIZE * 3)(%rdi, %rcx), %eax
+	movzbl	(VEC_SIZE * 3)(%rsi, %rcx), %ecx
 	subl	%ecx, %eax
-	/* No ymm register was touched.  */
-	ret
 # endif
-L(zero):
-	xorl	%eax, %eax
-	ret
-
+L(return_vzeroupper):
+	ZERO_UPPER_VEC_REGISTERS_RETURN
 
 
 	.p2align 4
@@ -414,6 +361,50 @@ L(last_1x_vec):
 	jnz	L(return_vec_0_end)
 	VZEROUPPER_RETURN
 
+	.p2align 4,, 13
+# ifdef USE_AS_WMEMCMP
+L(one_or_less):
+	jb	L(zero)
+	movl	(%rdi), %ecx
+	xorl	%edx, %edx
+	cmpl	(%rsi), %ecx
+	je	L(zero)
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+	/* No ymm register was touched.  */
+	ret
+# else
+L(one_or_less):
+	jb	L(zero)
+	movzbl	(%rsi), %ecx
+	movzbl	(%rdi), %eax
+	subl	%ecx, %eax
+	/* No ymm register was touched.  */
+	ret
+# endif
+
+L(zero):
+	xorl	%eax, %eax
+	ret
+
+	.p2align 4
+L(return_vec_0_lv):
+	bsfl	%eax, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	(%rdi, %rax), %ecx
+	xorl	%edx, %edx
+	cmpl	(%rsi, %rax), %ecx
+	/* NB: no partial register stall here because xorl zero idiom above.
+	 */
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	(%rsi, %rax), %ecx
+	movzbl	(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+	VZEROUPPER_RETURN
+
 	.p2align 4,, 10
 L(return_vec_0_end):
 	bsfl	%eax, %eax
@@ -431,7 +422,8 @@ L(return_vec_0_end):
 # endif
 	VZEROUPPER_RETURN
 
-	.p2align 4,, 6
+
+	.p2align 4,, 8
 L(return_vec_1_end):
 	bsfl	%eax, %eax
 	addl	%edx, %eax
@@ -448,6 +440,37 @@ L(return_vec_1_end):
 # endif
 	VZEROUPPER_RETURN
 
+
+
+
+	.p2align 4
+L(less_vec):
+	/* Check if one or less CHAR. This is necessary for size = 0 but is
+	   also faster for size = CHAR_SIZE.  */
+	cmpl	$CHAR_SIZE, %edx
+	jbe	L(one_or_less)
+
+	/* Check if loading one VEC from either s1 or s2 could cause a page
+	   cross. This can have false positives but is by far the fastest
+	   method.  */
+	movl	%edi, %eax
+	orl	%esi, %eax
+	andl	$(PAGE_SIZE - 1), %eax
+	cmpl	$(PAGE_SIZE - VEC_SIZE), %eax
+	ja	L(page_cross_less_vec)
+
+	/* No page cross possible.  */
+	vmovdqu	(%rsi), %ymm2
+	VPCMPEQ	(%rdi), %ymm2, %ymm2
+	vpmovmskb %ymm2, %eax
+	incl	%eax
+	/* Result will be zero if s1 and s2 match. Otherwise first set bit
+	   will be first mismatch.  */
+	bzhil	%edx, %eax, %edx
+	jnz	L(return_vec_0_lv)
+	xorl	%eax, %eax
+	VZEROUPPER_RETURN
+
 	.p2align 4
 L(page_cross_less_vec):
 	/* if USE_AS_WMEMCMP it can only be 0, 4, 8, 12, 16, 20, 24, 28
@@ -501,13 +524,15 @@ L(between_8_15):
 	.p2align 4,, 10
 L(between_16_31):
 	/* From 16 to 31 bytes.  No branch when size == 16.  */
-	vmovdqu	(%rsi), %xmm2
+
+	/* Use movups to save code size.  */
+	movups	(%rsi), %xmm2
 	VPCMPEQ	(%rdi), %xmm2, %xmm2
 	vpmovmskb %xmm2, %eax
 	subl	$0xffff, %eax
 	jnz	L(return_vec_0)
 	/* Use overlapping loads to avoid branches.  */
-	vmovdqu	-16(%rsi, %rdx), %xmm2
+	movups	-16(%rsi, %rdx), %xmm2
 	VPCMPEQ	-16(%rdi, %rdx), %xmm2, %xmm2
 	addl	$(VEC_SIZE - 16), %edx
 	vpmovmskb %xmm2, %eax
@@ -526,15 +551,16 @@ L(between_2_3):
 	shll	$8, %ecx
 	bswap	%eax
 	bswap	%ecx
-	movzbl	-1(%rdi, %rdx), %edi
-	movzbl	-1(%rsi, %rdx), %esi
-	orl	%edi, %eax
-	orl	%esi, %ecx
+	/* Partial register stall but any machine with AVX2 will also just
+	   insert merging uop. Doing this saves 6 bytes of code which causes
+	   memcmp() to take up one less cache line. Since page cross
+	   L(between_2_3) is relatively cold, this is likely worth it.  */
+	orb	-1(%rdi, %rdx), %al
+	orb	-1(%rsi, %rdx), %cl
 	/* Subtraction is okay because the upper 8 bits are zero.  */
 	subl	%ecx, %eax
 	/* No ymm register was touched.  */
 	ret
-
 # endif
 
 END (MEMCMP)
diff --git a/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S b/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S
index 76038cb58c..db41d8d1be 100644
--- a/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S
+++ b/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S
@@ -449,8 +449,9 @@ L(less_vec):
 	VPCMP	$4, (%rdi), %YMM2, %k1
 	kmovd	%k1, %eax
 	/* Create mask in ecx for potentially in bound matches.  */
-	bzhil	%edx, %eax, %eax
+	bzhil	%edx, %eax, %edx
 	jnz	L(return_vec_0_lv)
+    xorl    %eax, %eax
 	ret
 
 	.p2align 4,, 4
-- 
2.25.1

