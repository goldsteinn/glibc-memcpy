From 5556a3efbd398a372b0734b47efed950da5f2ea9 Mon Sep 17 00:00:00 2001
From: Noah Goldstein <goldstein.w.n@gmail.com>
Date: Sat, 18 Sep 2021 02:59:34 -0500
Subject: [PATCH 07/10] run2

---
 sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S |  18 +-
 sysdeps/x86_64/multiarch/memcmp-evex-movbe.S | 225 +++++++++----------
 2 files changed, 119 insertions(+), 124 deletions(-)

diff --git a/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S b/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
index 4b95dd7138..79ba9df543 100644
--- a/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
+++ b/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
@@ -486,14 +486,13 @@ L(between_8_15):
 	subl	$0xffff, %eax
 	jnz	L(return_vec_0)
 	/* Use overlapping loads to avoid branches.  */
-	leaq	-8(%rdi, %rdx), %rdi
-	leaq	-8(%rsi, %rdx), %rsi
-	vmovq	(%rdi), %xmm1
-	vmovq	(%rsi), %xmm2
+	vmovq	-8(%rdi, %rdx), %xmm1
+	vmovq	-8(%rsi, %rdx), %xmm2
 	VPCMPEQ	%xmm1, %xmm2, %xmm2
+    addl    $(VEC_SIZE - 8), %edx
 	vpmovmskb %xmm2, %eax
 	subl	$0xffff, %eax
-	jnz	L(return_vec_0)
+	jnz	L(return_vec_0_end)
 	/* No ymm register was touched.  */
 	ret
 
@@ -505,16 +504,13 @@ L(between_16_31):
 	vpmovmskb %xmm2, %eax
 	subl	$0xffff, %eax
 	jnz	L(return_vec_0)
-
 	/* Use overlapping loads to avoid branches.  */
-
 	vmovdqu	-16(%rsi, %rdx), %xmm2
-	leaq	-16(%rdi, %rdx), %rdi
-	leaq	-16(%rsi, %rdx), %rsi
-	VPCMPEQ	(%rdi), %xmm2, %xmm2
+	VPCMPEQ	-16(%rdi, %rdx), %xmm2, %xmm2
+    addl    $(VEC_SIZE - 16), %edx
 	vpmovmskb %xmm2, %eax
 	subl	$0xffff, %eax
-	jnz	L(return_vec_0)
+	jnz	L(return_vec_0_end)
 	/* No ymm register was touched.  */
 	ret
 
diff --git a/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S b/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S
index e552e96047..a215d0ab0f 100644
--- a/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S
+++ b/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S
@@ -163,6 +163,7 @@ ENTRY_P2ALIGN (MEMCMP, 6)
 	/* NB: eax must be zero to reach here.  */
 	ret
 
+
 	.p2align 4
 L(less_vec):
 	/* Check if one or less CHAR. This is necessary for size = 0 but is
@@ -188,34 +189,8 @@ L(less_vec):
 	jnz	L(return_vec_0)
 	ret
 
-	/* NB: L(one_or_less) fits in alignment padding between L(less_vec)
-	   and L(return_vec_0).  */
-# ifdef USE_AS_WMEMCMP
-L(one_or_less):
-	jb	L(zero)
-	movl	(%rdi), %ecx
-	xorl	%edx, %edx
-	cmpl	(%rsi), %ecx
-	je	L(zero)
-	setg	%dl
-	leal	-1(%rdx, %rdx), %eax
-	ret
-# else
-L(one_or_less):
-	jb	L(zero)
-	movzbl	(%rsi), %ecx
-	movzbl	(%rdi), %eax
-	subl	%ecx, %eax
-	ret
-# endif
-L(zero):
-	xorl	%eax, %eax
-	ret
-
-
-	.p2align 4
 L(return_vec_0):
-	tzcntl	%eax, %eax
+	bsfl	%eax, %eax
 # ifdef USE_AS_WMEMCMP
 	movl	(%rdi, %rax, CHAR_SIZE), %ecx
 	xorl	%edx, %edx
@@ -232,40 +207,9 @@ L(return_vec_0):
 	ret
 
 
-
-	.p2align 4
-L(return_vec_1):
-	tzcntl	%eax, %eax
-# ifdef USE_AS_WMEMCMP
-	movl	VEC_SIZE(%rdi, %rax, CHAR_SIZE), %ecx
-	xorl	%edx, %edx
-	cmpl	VEC_SIZE(%rsi, %rax, CHAR_SIZE), %ecx
-	setg	%dl
-	leal	-1(%rdx, %rdx), %eax
-# else
-	movzbl	VEC_SIZE(%rsi, %rax), %ecx
-	movzbl	VEC_SIZE(%rdi, %rax), %eax
-	subl	%ecx, %eax
-# endif
-	ret
-
-	.p2align 4,, 10
-L(return_vec_2):
-	tzcntl	%eax, %eax
-# ifdef USE_AS_WMEMCMP
-	movl	(VEC_SIZE * 2)(%rdi, %rax, CHAR_SIZE), %ecx
-	xorl	%edx, %edx
-	cmpl	(VEC_SIZE * 2)(%rsi, %rax, CHAR_SIZE), %ecx
-	setg	%dl
-	leal	-1(%rdx, %rdx), %eax
-# else
-	movzbl	(VEC_SIZE * 2)(%rsi, %rax), %ecx
-	movzbl	(VEC_SIZE * 2)(%rdi, %rax), %eax
-	subl	%ecx, %eax
-# endif
-	ret
-
 	.p2align 4,, 8
+L(8x_end_return_vec_0_1_2_3):
+	movq	%rdx, %rdi
 L(8x_return_vec_0_1_2_3):
 	addq	%rdi, %rsi
 L(return_vec_0_1_2_3):
@@ -285,7 +229,7 @@ L(return_vec_0_1_2_3):
 	jnz	L(return_vec_2)
 	.p2align 4,, 4
 L(return_vec_3):
-	tzcntl	%ecx, %ecx
+	bsfl	%ecx, %ecx
 # ifdef USE_AS_WMEMCMP
 	movl	(VEC_SIZE * 3)(%rdi, %rcx, CHAR_SIZE), %eax
 	xorl	%edx, %edx
@@ -299,64 +243,67 @@ L(return_vec_3):
 # endif
 	ret
 
+	/* NB: L(one_or_less) fits in alignment padding between L(less_vec)
+	   and L(return_vec_0).  */
+# ifdef USE_AS_WMEMCMP
+L(one_or_less):
+	jb	L(zero)
+	movl	(%rdi), %ecx
+	xorl	%edx, %edx
+	cmpl	(%rsi), %ecx
+	je	L(zero)
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+	ret
+# else
+L(one_or_less):
+	jb	L(zero)
+	movzbl	(%rsi), %ecx
+	movzbl	(%rdi), %eax
+	subl	%ecx, %eax
+	ret
+# endif
+L(zero):
+	xorl	%eax, %eax
+	ret
 
 
 
 	.p2align 4
-L(last_2x_vec):
-	/* Check second to last VEC.  */
-	VMOVU	-(VEC_SIZE * 2)(%rsi, %rdx, CHAR_SIZE), %YMM1
-	VPCMP	$4, -(VEC_SIZE * 2)(%rdi, %rdx, CHAR_SIZE), %YMM1, %k1
-	kmovd	%k1, %eax
-	testl	%eax, %eax
-	jnz	L(return_vec_1_end)
-
-	/* Check last VEC.  */
-	.p2align 4
-L(last_1x_vec):
-	VMOVU	-(VEC_SIZE * 1)(%rsi, %rdx, CHAR_SIZE), %YMM1
-	VPCMP	$4, -(VEC_SIZE * 1)(%rdi, %rdx, CHAR_SIZE), %YMM1, %k1
-	kmovd	%k1, %eax
-	testl	%eax, %eax
-	jnz	L(return_vec_0_end)
-	ret
-
-	.p2align 4,, 10
-L(return_vec_1_end):
-	tzcntl	%eax, %eax
-	addl	%edx, %eax
+L(return_vec_1):
+	bsfl	%eax, %eax
 # ifdef USE_AS_WMEMCMP
-	movl	-(VEC_SIZE * 2)(%rdi, %rax, CHAR_SIZE), %ecx
+	movl	VEC_SIZE(%rdi, %rax, CHAR_SIZE), %ecx
 	xorl	%edx, %edx
-	cmpl	-(VEC_SIZE * 2)(%rsi, %rax, CHAR_SIZE), %ecx
+	cmpl	VEC_SIZE(%rsi, %rax, CHAR_SIZE), %ecx
 	setg	%dl
 	leal	-1(%rdx, %rdx), %eax
 # else
-	movzbl	-(VEC_SIZE * 2)(%rsi, %rax), %ecx
-	movzbl	-(VEC_SIZE * 2)(%rdi, %rax), %eax
+	movzbl	VEC_SIZE(%rsi, %rax), %ecx
+	movzbl	VEC_SIZE(%rdi, %rax), %eax
 	subl	%ecx, %eax
 # endif
 	ret
 
 	.p2align 4,, 10
-L(return_vec_0_end):
-	tzcntl	%eax, %eax
-	addl	%edx, %eax
+L(return_vec_2):
+	bsfl	%eax, %eax
 # ifdef USE_AS_WMEMCMP
-	movl	-VEC_SIZE(%rdi, %rax, CHAR_SIZE), %ecx
+	movl	(VEC_SIZE * 2)(%rdi, %rax, CHAR_SIZE), %ecx
 	xorl	%edx, %edx
-	cmpl	-VEC_SIZE(%rsi, %rax, CHAR_SIZE), %ecx
+	cmpl	(VEC_SIZE * 2)(%rsi, %rax, CHAR_SIZE), %ecx
 	setg	%dl
 	leal	-1(%rdx, %rdx), %eax
 # else
-	movzbl	-VEC_SIZE(%rsi, %rax), %ecx
-	movzbl	-VEC_SIZE(%rdi, %rax), %eax
+	movzbl	(VEC_SIZE * 2)(%rsi, %rax), %ecx
+	movzbl	(VEC_SIZE * 2)(%rdi, %rax), %eax
 	subl	%ecx, %eax
 # endif
 	ret
 
 
 
+
 	.p2align 4
 L(more_8x_vec):
 	/* Set end of s1 in rdx.  */
@@ -397,6 +344,7 @@ L(loop_4x_vec):
 	VMOVU	(VEC_SIZE * 2)(%rsi, %rdx), %YMM3
 	cmpl	$(VEC_SIZE * 2), %edi
 	jae	L(8x_last_2x_vec)
+	vpxorq	(VEC_SIZE * 2)(%rdx), %YMM3, %YMM3
 
 	VMOVU	(%rsi, %rdx), %YMM1
 	vpxorq	(%rdx), %YMM1, %YMM1
@@ -404,7 +352,7 @@ L(loop_4x_vec):
 	VMOVU	VEC_SIZE(%rsi, %rdx), %YMM2
 	vpxorq	VEC_SIZE(%rdx), %YMM2, %YMM2
 
-	vpxorq	(VEC_SIZE * 2)(%rdx), %YMM3, %YMM3
+
 	vpternlogd $0xfe, %YMM1, %YMM2, %YMM3
 
 	VMOVU	(VEC_SIZE * 3)(%rsi, %rdx), %YMM4
@@ -412,14 +360,11 @@ L(loop_4x_vec):
 	VPTEST	%YMM4, %YMM4, %k1
 	kmovd	%k1, %ecx
 	/* Restore s1 pointer to rdi.  */
-	movq	%rdx, %rdi
 	testl	%ecx, %ecx
-	jnz	L(8x_return_vec_0_1_2_3)
+	jnz	L(8x_end_return_vec_0_1_2_3)
 	/* NB: eax must be zero to reach here.  */
 	ret
 
-
-
 	/* Only entry is from L(more_8x_vec).  */
 	.p2align 4,, 10
 L(8x_last_2x_vec):
@@ -437,11 +382,14 @@ L(8x_last_1x_vec):
 	ret
 
 
-	.p2align 4
+
+
+
+	.p2align 4,, 4
 L(8x_return_vec_2):
 	subq	$VEC_SIZE, %rdx
 L(8x_return_vec_3):
-	tzcntl	%eax, %eax
+	bsfl	%eax, %eax
 # ifdef USE_AS_WMEMCMP
 	leaq	(%rdx, %rax, CHAR_SIZE), %rax
 	movl	(VEC_SIZE * 3)(%rax), %ecx
@@ -457,9 +405,63 @@ L(8x_return_vec_3):
 # endif
 	ret
 
+	.p2align 4,, 10
+L(last_2x_vec):
+	/* Check second to last VEC.  */
+	VMOVU	-(VEC_SIZE * 2)(%rsi, %rdx, CHAR_SIZE), %YMM1
+	VPCMP	$4, -(VEC_SIZE * 2)(%rdi, %rdx, CHAR_SIZE), %YMM1, %k1
+	kmovd	%k1, %eax
+	testl	%eax, %eax
+	jnz	L(return_vec_1_end)
 
-
+	/* Check last VEC.  */
 	.p2align 4
+L(last_1x_vec):
+	VMOVU	-(VEC_SIZE * 1)(%rsi, %rdx, CHAR_SIZE), %YMM1
+	VPCMP	$4, -(VEC_SIZE * 1)(%rdi, %rdx, CHAR_SIZE), %YMM1, %k1
+	kmovd	%k1, %eax
+	testl	%eax, %eax
+	jnz	L(return_vec_0_end)
+	ret
+
+
+
+	.p2align 4,, 10
+L(return_vec_1_end):
+	bsfl	%eax, %eax
+	addl	%edx, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	-(VEC_SIZE * 2)(%rdi, %rax, CHAR_SIZE), %ecx
+	xorl	%edx, %edx
+	cmpl	-(VEC_SIZE * 2)(%rsi, %rax, CHAR_SIZE), %ecx
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	-(VEC_SIZE * 2)(%rsi, %rax), %ecx
+	movzbl	-(VEC_SIZE * 2)(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+	ret
+
+	.p2align 4,, 10
+L(return_vec_0_end):
+	tzcntl	%eax, %eax
+	addl	%edx, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	-VEC_SIZE(%rdi, %rax, CHAR_SIZE), %ecx
+	xorl	%edx, %edx
+	cmpl	-VEC_SIZE(%rsi, %rax, CHAR_SIZE), %ecx
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	-VEC_SIZE(%rsi, %rax), %ecx
+	movzbl	-VEC_SIZE(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+	ret
+
+
+	.p2align 4,, 8
 L(page_cross_less_vec):
 	/* if USE_AS_WMEMCMP it can only be 0, 4, 8, 12, 16, 20, 24, 28
 	   bytes.  */
@@ -499,14 +501,13 @@ L(between_8_15):
 	testl	%eax, %eax
 	jnz	L(return_vec_0)
 	/* Use overlapping loads to avoid branches.  */
-	leaq	-8(%rdi, %rdx, CHAR_SIZE), %rdi
-	leaq	-8(%rsi, %rdx, CHAR_SIZE), %rsi
-	vmovq	(%rdi), %xmm1
-	vmovq	(%rsi), %xmm2
+	vmovq	-8(%rdi, %rdx, CHAR_SIZE), %xmm1
+	vmovq	-8(%rsi, %rdx, CHAR_SIZE), %xmm2
 	VPCMP	$4, %xmm1, %xmm2, %k1
+	addl	$(VEC_SIZE - 8), %edx
 	kmovd	%k1, %eax
 	testl	%eax, %eax
-	jnz	L(return_vec_0)
+	jnz	L(return_vec_0_end)
 	ret
 
 
@@ -522,12 +523,11 @@ L(between_16_31):
 	/* Use overlapping loads to avoid branches.  */
 
 	vmovdqu	-16(%rsi, %rdx, CHAR_SIZE), %xmm2
-	leaq	-16(%rdi, %rdx, CHAR_SIZE), %rdi
-	leaq	-16(%rsi, %rdx, CHAR_SIZE), %rsi
-	VPCMP	$4, (%rdi), %xmm2, %k1
+	VPCMP	$4, -16(%rdi, %rdx, CHAR_SIZE), %xmm2, %k1
+	addl	$(VEC_SIZE - 16), %edx
 	kmovd	%k1, %eax
 	testl	%eax, %eax
-	jnz	L(return_vec_0)
+	jnz	L(return_vec_0_end)
 	ret
 
 # ifndef USE_AS_WMEMCMP
@@ -546,7 +546,6 @@ L(between_2_3):
 	/* Subtraction is okay because the upper 8 bits are zero.  */
 	subl	%ecx, %eax
 	ret
-# endif
-    
+# endif    
 END (MEMCMP)
 #endif
-- 
2.25.1

