From d9043ac9026c3ddd4ad0fdffcbfdff6879bf4b85 Mon Sep 17 00:00:00 2001
From: Noah Goldstein <goldstein.w.n@gmail.com>
Date: Thu, 7 Oct 2021 19:36:24 -0500
Subject: [PATCH 5/5] bothways

---
 sysdeps/x86_64/multiarch/bcmp-avx2.S         | 552 +++++++++++++++++-
 sysdeps/x86_64/multiarch/bcmp-evex.S         | 553 ++++++++++++++++++-
 sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S |  50 +-
 sysdeps/x86_64/multiarch/memcmp-evex-movbe.S |  51 +-
 4 files changed, 1171 insertions(+), 35 deletions(-)

diff --git a/sysdeps/x86_64/multiarch/bcmp-avx2.S b/sysdeps/x86_64/multiarch/bcmp-avx2.S
index d7f449f677..44892919eb 100644
--- a/sysdeps/x86_64/multiarch/bcmp-avx2.S
+++ b/sysdeps/x86_64/multiarch/bcmp-avx2.S
@@ -1,4 +1,4 @@
-/* bcmp optimized with AVX2.
+/* memcmp/wmemcmp optimized with AVX2.
    Copyright (C) 2017-2021 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -16,8 +16,554 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
+#if IS_IN (libc)
+
+/* memcmp/wmemcmp is implemented as:
+   1. Use ymm vector compares when possible. The only case where
+      vector compares is not possible for when size < VEC_SIZE
+      and loading from either s1 or s2 would cause a page cross.
+   2. For size from 2 to 7 bytes on page cross, load as big endian
+      with movbe and bswap to avoid branches.
+   3. Use xmm vector compare when size >= 4 bytes for memcmp or
+      size >= 8 bytes for wmemcmp.
+   4. Optimistically compare up to first 4 * VEC_SIZE one at a
+      to check for early mismatches. Only do this if its guranteed the
+      work is not wasted.
+   5. If size is 8 * VEC_SIZE or less, unroll the loop.
+   6. Compare 4 * VEC_SIZE at a time with the aligned first memory
+      area.
+   7. Use 2 vector compares when size is 2 * VEC_SIZE or less.
+   8. Use 4 vector compares when size is 4 * VEC_SIZE or less.
+   9. Use 8 vector compares when size is 8 * VEC_SIZE or less.  */
+
+
+# include <sysdep.h>
+
 # ifndef MEMCMP
 #  define MEMCMP	__bcmp_avx2
 # endif
-# define USE_AS_BCMP	1
-#include "memcmp-avx2-movbe.S"
+
+# ifdef USE_AS_WMEMCMP
+#  define CHAR_SIZE	4
+#  define VPCMPEQ	vpcmpeqd
+# else
+#  define CHAR_SIZE	1
+#  define VPCMPEQ	vpcmpeqb
+# endif
+
+# ifndef VZEROUPPER
+#  define VZEROUPPER	vzeroupper
+# endif
+
+# ifndef SECTION
+#  define SECTION(p)	p##.avx
+# endif
+
+# define VEC_SIZE 32
+# define PAGE_SIZE	4096
+
+/* Warning!
+           wmemcmp has to use SIGNED comparison for elements.
+           memcmp has to use UNSIGNED comparison for elemnts.
+*/
+
+	.section SECTION(.text),"ax",@progbits
+ENTRY (MEMCMP)
+# ifdef USE_AS_WMEMCMP
+	shl	$2, %RDX_LP
+# elif defined __ILP32__
+	/* Clear the upper 32 bits.  */
+	movl	%edx, %edx
+# endif
+    xorl    %ecx, %ecx
+	cmp	$VEC_SIZE, %RDX_LP
+	jb	L(less_vec)
+
+	/* From VEC to 2 * VEC.  No branch when size == VEC_SIZE.  */
+	vmovdqu	(%rsi), %ymm1
+	VPCMPEQ	(%rdi), %ymm1, %ymm1
+	vpmovmskb %ymm1, %eax
+	/* NB: eax must be destination register if going to
+	   L(return_vec_[0,2]). For L(return_vec_3 destination register
+	   must be ecx.  */
+	incl	%eax
+	jnz	L(return_vec_0)
+
+	cmpq	$(VEC_SIZE * 2), %rdx
+	jbe	L(last_1x_vec)
+
+	/* Check second VEC no matter what.  */
+	vmovdqu	VEC_SIZE(%rsi), %ymm2
+	VPCMPEQ	VEC_SIZE(%rdi), %ymm2, %ymm2
+	vpmovmskb %ymm2, %eax
+	/* If all 4 VEC where equal eax will be all 1s so incl will
+	   overflow and set zero flag.  */
+	incl	%eax
+	jnz	L(return_vec_1)
+
+	/* Less than 4 * VEC.  */
+	cmpq	$(VEC_SIZE * 4), %rdx
+	jbe	L(last_2x_vec)
+
+	/* Check third and fourth VEC no matter what.  */
+	vmovdqu	(VEC_SIZE * 2)(%rsi), %ymm3
+	VPCMPEQ	(VEC_SIZE * 2)(%rdi), %ymm3, %ymm3
+	vpmovmskb %ymm3, %eax
+	incl	%eax
+	jnz	L(return_vec_2)
+	vmovdqu	(VEC_SIZE * 3)(%rsi), %ymm4
+	VPCMPEQ	(VEC_SIZE * 3)(%rdi), %ymm4, %ymm4
+	vpmovmskb %ymm4, %r8d
+	incl	%r8d
+	jnz	L(return_vec_3)
+
+	/* Go to 4x VEC loop.  */
+	cmpq	$(VEC_SIZE * 8), %rdx
+	ja	L(more_8x_vec)
+
+	/* Handle remainder of size = 4 * VEC + 1 to 8 * VEC without any
+	   branches.  */
+
+	/* Load first two VEC from s2 before adjusting addresses.  */
+	vmovdqu	-(VEC_SIZE * 4)(%rsi, %rdx), %ymm1
+	vmovdqu	-(VEC_SIZE * 3)(%rsi, %rdx), %ymm2
+	leaq	-(4 * VEC_SIZE)(%rdi, %rdx), %rdi
+	leaq	-(4 * VEC_SIZE)(%rsi, %rdx), %rsi
+
+	/* Wait to load from s1 until addressed adjust due to
+	   unlamination of microfusion with complex address mode.  */
+	VPCMPEQ	(%rdi), %ymm1, %ymm1
+	VPCMPEQ	(VEC_SIZE)(%rdi), %ymm2, %ymm2
+
+	vmovdqu	(VEC_SIZE * 2)(%rsi), %ymm3
+	VPCMPEQ	(VEC_SIZE * 2)(%rdi), %ymm3, %ymm3
+	vmovdqu	(VEC_SIZE * 3)(%rsi), %ymm4
+	VPCMPEQ	(VEC_SIZE * 3)(%rdi), %ymm4, %ymm4
+
+	/* Reduce VEC0 - VEC4.  */
+	vpand	%ymm1, %ymm2, %ymm5
+	vpand	%ymm3, %ymm4, %ymm6
+	vpand	%ymm5, %ymm6, %ymm7
+	vpmovmskb %ymm7, %r8d
+	incl	%r8d
+	jnz	L(return_vec_0_1_2_3)
+	/* NB: eax must be zero to reach here.  */
+L(ret0):
+	VZEROUPPER_RETURN
+
+	.p2align 4
+L(return_vec_0):
+	testl	%ecx, %ecx
+	jz	L(ret0)
+	tzcntl	%eax, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	(%rdi, %rax), %ecx
+	xorl	%edx, %edx
+	cmpl	(%rsi, %rax), %ecx
+	/* NB: no partial register stall here because xorl zero idiom
+	   above.  */
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	(%rsi, %rax), %ecx
+	movzbl	(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+L(return_vzeroupper):
+	ZERO_UPPER_VEC_REGISTERS_RETURN
+
+	.p2align 4
+L(return_vec_1):
+	testl	%ecx, %ecx
+	jz	L(ret0)
+	tzcntl	%eax, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	VEC_SIZE(%rdi, %rax), %ecx
+	xorl	%edx, %edx
+	cmpl	VEC_SIZE(%rsi, %rax), %ecx
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	VEC_SIZE(%rsi, %rax), %ecx
+	movzbl	VEC_SIZE(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+	VZEROUPPER_RETURN
+
+	.p2align 4
+L(return_vec_2):
+	testl	%ecx, %ecx
+	jz	L(ret0)
+	tzcntl	%eax, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	(VEC_SIZE * 2)(%rdi, %rax), %ecx
+	xorl	%edx, %edx
+	cmpl	(VEC_SIZE * 2)(%rsi, %rax), %ecx
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	(VEC_SIZE * 2)(%rsi, %rax), %ecx
+	movzbl	(VEC_SIZE * 2)(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+	VZEROUPPER_RETURN
+L(ret_nz):
+	movl	$1, %eax
+	VZEROUPPER_RETURN
+
+	/* NB: p2align 5 here to ensure 4x loop is 32 byte aligned.  */
+	.p2align 5
+L(8x_return_vec_0_1_2_3):
+	/* Returning from L(more_8x_vec) requires restoring rsi.  */
+	addq	%rdi, %rsi
+L(return_vec_0_1_2_3):
+	testl	%ecx, %ecx
+	jz	L(ret_nz)
+
+	vpmovmskb %ymm1, %eax
+	incl	%eax
+	jnz	L(return_vec_0)
+
+	vpmovmskb %ymm2, %eax
+	incl	%eax
+	jnz	L(return_vec_1)
+
+	vpmovmskb %ymm3, %eax
+	incl	%eax
+	jnz	L(return_vec_2)
+L(return_vec_3):
+	testl	%ecx, %ecx
+	jz	L(ret_nz)
+	tzcntl	%r8d, %r8d
+# ifdef USE_AS_WMEMCMP
+	movl	(VEC_SIZE * 3)(%rdi, %r8), %eax
+	xorl	%edx, %edx
+	cmpl	(VEC_SIZE * 3)(%rsi, %r8), %eax
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	(VEC_SIZE * 3)(%rdi, %r8), %eax
+	movzbl	(VEC_SIZE * 3)(%rsi, %r8), %ecx
+	subl	%ecx, %eax
+# endif
+	VZEROUPPER_RETURN
+
+	.p2align 4
+L(more_8x_vec):
+	/* Set end of s1 in rdx.  */
+	leaq	-(VEC_SIZE * 4)(%rdi, %rdx), %rdx
+	/* rsi stores s2 - s1. This allows loop to only update one
+	   pointer.  */
+	subq	%rdi, %rsi
+	/* Align s1 pointer.  */
+	andq	$-VEC_SIZE, %rdi
+	/* Adjust because first 4x vec where check already.  */
+	subq	$-(VEC_SIZE * 4), %rdi
+	.p2align 4
+L(loop_4x_vec):
+	/* rsi has s2 - s1 so get correct address by adding s1 (in rdi).
+	 */
+	vmovdqu	(%rsi, %rdi), %ymm1
+	VPCMPEQ	(%rdi), %ymm1, %ymm1
+
+	vmovdqu	VEC_SIZE(%rsi, %rdi), %ymm2
+	VPCMPEQ	VEC_SIZE(%rdi), %ymm2, %ymm2
+
+	vmovdqu	(VEC_SIZE * 2)(%rsi, %rdi), %ymm3
+	VPCMPEQ	(VEC_SIZE * 2)(%rdi), %ymm3, %ymm3
+
+	vmovdqu	(VEC_SIZE * 3)(%rsi, %rdi), %ymm4
+	VPCMPEQ	(VEC_SIZE * 3)(%rdi), %ymm4, %ymm4
+
+	vpand	%ymm1, %ymm2, %ymm5
+	vpand	%ymm3, %ymm4, %ymm6
+	vpand	%ymm5, %ymm6, %ymm7
+	vpmovmskb %ymm7, %r8d
+	incl	%r8d
+	jnz	L(8x_return_vec_0_1_2_3)
+	subq	$-(VEC_SIZE * 4), %rdi
+	/* Check if s1 pointer at end.  */
+	cmpq	%rdx, %rdi
+	jb	L(loop_4x_vec)
+
+	subq	%rdx, %rdi
+	/* rdi has 4 * VEC_SIZE - remaining length.  */
+	cmpl	$(VEC_SIZE * 3), %edi
+	jae	L(8x_last_1x_vec)
+	/* Load regardless of branch.  */
+	vmovdqu	(VEC_SIZE * 2)(%rsi, %rdx), %ymm3
+	cmpl	$(VEC_SIZE * 2), %edi
+	jae	L(8x_last_2x_vec)
+
+	/* Check last 4 VEC.  */
+	vmovdqu	(%rsi, %rdx), %ymm1
+	VPCMPEQ	(%rdx), %ymm1, %ymm1
+
+	vmovdqu	VEC_SIZE(%rsi, %rdx), %ymm2
+	VPCMPEQ	VEC_SIZE(%rdx), %ymm2, %ymm2
+
+	VPCMPEQ	(VEC_SIZE * 2)(%rdx), %ymm3, %ymm3
+
+	vmovdqu	(VEC_SIZE * 3)(%rsi, %rdx), %ymm4
+	VPCMPEQ	(VEC_SIZE * 3)(%rdx), %ymm4, %ymm4
+
+	vpand	%ymm1, %ymm2, %ymm5
+	vpand	%ymm3, %ymm4, %ymm6
+	vpand	%ymm5, %ymm6, %ymm7
+	vpmovmskb %ymm7, %r8d
+	/* Restore s1 pointer to rdi.  */
+	movq	%rdx, %rdi
+	incl	%r8d
+	jnz	L(8x_return_vec_0_1_2_3)
+	/* NB: eax must be zero to reach here.  */
+	VZEROUPPER_RETURN
+
+	/* Only entry is from L(more_8x_vec).  */
+	.p2align 4
+L(8x_last_2x_vec):
+	/* Check second to last VEC. rdx store end pointer of s1 and
+	   ymm3 has already been loaded with second to last VEC from s2.
+	 */
+	VPCMPEQ	(VEC_SIZE * 2)(%rdx), %ymm3, %ymm3
+	vpmovmskb %ymm3, %eax
+	incl	%eax
+	jnz	L(8x_return_vec_2)
+	/* Check last VEC.  */
+	.p2align 4
+L(8x_last_1x_vec):
+	vmovdqu	(VEC_SIZE * 3)(%rsi, %rdx), %ymm4
+	VPCMPEQ	(VEC_SIZE * 3)(%rdx), %ymm4, %ymm4
+	vpmovmskb %ymm4, %eax
+	incl	%eax
+	jnz	L(8x_return_vec_3)
+	VZEROUPPER_RETURN
+
+	.p2align 4
+L(last_2x_vec):
+	/* Check second to last VEC.  */
+	vmovdqu	-(VEC_SIZE * 2)(%rsi, %rdx), %ymm1
+	VPCMPEQ	-(VEC_SIZE * 2)(%rdi, %rdx), %ymm1, %ymm1
+	vpmovmskb %ymm1, %eax
+	incl	%eax
+	jnz	L(return_vec_1_end)
+	/* Check last VEC.  */
+L(last_1x_vec):
+	vmovdqu	-(VEC_SIZE * 1)(%rsi, %rdx), %ymm1
+	VPCMPEQ	-(VEC_SIZE * 1)(%rdi, %rdx), %ymm1, %ymm1
+	vpmovmskb %ymm1, %eax
+	incl	%eax
+	jnz	L(return_vec_0_end)
+	VZEROUPPER_RETURN
+
+	.p2align 4
+L(8x_return_vec_2):
+	subq	$VEC_SIZE, %rdx
+L(8x_return_vec_3):
+	testl	%ecx, %ecx
+	jz	L(ret1)
+
+	tzcntl	%eax, %eax
+	addq	%rdx, %rax
+# ifdef USE_AS_WMEMCMP
+	movl	(VEC_SIZE * 3)(%rax), %ecx
+	xorl	%edx, %edx
+	cmpl	(VEC_SIZE * 3)(%rsi, %rax), %ecx
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	(VEC_SIZE * 3)(%rsi, %rax), %ecx
+	movzbl	(VEC_SIZE * 3)(%rax), %eax
+	subl	%ecx, %eax
+# endif
+L(ret1):
+	VZEROUPPER_RETURN
+
+	.p2align 4
+L(return_vec_1_end):
+	testl	%ecx, %ecx
+	jz	L(ret1)
+	tzcntl	%eax, %eax
+	addl	%edx, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	-(VEC_SIZE * 2)(%rdi, %rax), %ecx
+	xorl	%edx, %edx
+	cmpl	-(VEC_SIZE * 2)(%rsi, %rax), %ecx
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	-(VEC_SIZE * 2)(%rsi, %rax), %ecx
+	movzbl	-(VEC_SIZE * 2)(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+	VZEROUPPER_RETURN
+
+	.p2align 4
+L(return_vec_0_end):
+	testl	%ecx, %ecx
+	jz	L(ret1)
+	tzcntl	%eax, %eax
+	addl	%edx, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	-VEC_SIZE(%rdi, %rax), %ecx
+	xorl	%edx, %edx
+	cmpl	-VEC_SIZE(%rsi, %rax), %ecx
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	-VEC_SIZE(%rsi, %rax), %ecx
+	movzbl	-VEC_SIZE(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+	VZEROUPPER_RETURN
+
+	.p2align 4
+L(less_vec):
+	/* Check if one or less CHAR. This is necessary for size = 0 but
+	   is also faster for size = CHAR_SIZE.  */
+	cmpl	$CHAR_SIZE, %edx
+	jbe	L(one_or_less)
+
+	/* Check if loading one VEC from either s1 or s2 could cause a
+	   page cross. This can have false positives but is by far the
+	   fastest method.  */
+	movl	%edi, %eax
+	orl	%esi, %eax
+	andl	$(PAGE_SIZE - 1), %eax
+	cmpl	$(PAGE_SIZE - VEC_SIZE), %eax
+	jg	L(page_cross_less_vec)
+
+	/* No page cross possible.  */
+	vmovdqu	(%rsi), %ymm2
+	VPCMPEQ	(%rdi), %ymm2, %ymm2
+	vpmovmskb %ymm2, %eax
+	incl	%eax
+	/* Result will be zero if s1 and s2 match. Otherwise first set
+	   bit will be first mismatch.  */
+	bzhil	%edx, %eax, %edx
+	jnz	L(return_vec_0)
+	xorl	%eax, %eax
+	VZEROUPPER_RETURN
+
+	.p2align 4
+L(page_cross_less_vec):
+	/* if USE_AS_WMEMCMP it can only be 0, 4, 8, 12, 16, 20, 24, 28
+	   bytes.  */
+	cmpl	$16, %edx
+	jae	L(between_16_31)
+# ifndef USE_AS_WMEMCMP
+	cmpl	$8, %edx
+	jae	L(between_8_15)
+	cmpl	$4, %edx
+	jae	L(between_4_7)
+
+	/* Load as big endian to avoid branches.  */
+	movzwl	(%rdi), %eax
+	movzwl	(%rsi), %ecx
+	shll	$8, %eax
+	shll	$8, %ecx
+	bswap	%eax
+	bswap	%ecx
+	movzbl	-1(%rdi, %rdx), %edi
+	movzbl	-1(%rsi, %rdx), %esi
+	orl	%edi, %eax
+	orl	%esi, %ecx
+	/* Subtraction is okay because the upper 8 bits are zero.  */
+	subl	%ecx, %eax
+	/* No ymm register was touched.  */
+	ret
+
+	.p2align 4
+L(one_or_less):
+	jb	L(zero)
+	movzbl	(%rsi), %ecx
+	movzbl	(%rdi), %eax
+	subl	%ecx, %eax
+	/* No ymm register was touched.  */
+	ret
+
+	.p2align 4
+L(between_8_15):
+# endif
+	/* If USE_AS_WMEMCMP fall through into 8-15 byte case.  */
+	vmovq	(%rdi), %xmm1
+	vmovq	(%rsi), %xmm2
+	VPCMPEQ	%xmm1, %xmm2, %xmm2
+	vpmovmskb %xmm2, %eax
+	subl	$0xffff, %eax
+	jnz	L(return_vec_0)
+	/* Use overlapping loads to avoid branches.  */
+	leaq	-8(%rdi, %rdx), %rdi
+	leaq	-8(%rsi, %rdx), %rsi
+	vmovq	(%rdi), %xmm1
+	vmovq	(%rsi), %xmm2
+	VPCMPEQ	%xmm1, %xmm2, %xmm2
+	vpmovmskb %xmm2, %eax
+	subl	$0xffff, %eax
+	jnz	L(return_vec_0)
+	/* No ymm register was touched.  */
+	ret
+
+	.p2align 4
+L(zero):
+	xorl	%eax, %eax
+	ret
+
+	.p2align 4
+L(between_16_31):
+	/* From 16 to 31 bytes.  No branch when size == 16.  */
+	vmovdqu	(%rsi), %xmm2
+	VPCMPEQ	(%rdi), %xmm2, %xmm2
+	vpmovmskb %xmm2, %eax
+	subl	$0xffff, %eax
+	jnz	L(return_vec_0)
+
+	/* Use overlapping loads to avoid branches.  */
+
+	vmovdqu	-16(%rsi, %rdx), %xmm2
+	leaq	-16(%rdi, %rdx), %rdi
+	leaq	-16(%rsi, %rdx), %rsi
+	VPCMPEQ	(%rdi), %xmm2, %xmm2
+	vpmovmskb %xmm2, %eax
+	subl	$0xffff, %eax
+	jnz	L(return_vec_0)
+	/* No ymm register was touched.  */
+	ret
+
+# ifdef USE_AS_WMEMCMP
+	.p2align 4
+L(one_or_less):
+	jb	L(zero)
+	movl	(%rdi), %ecx
+	xorl	%edx, %edx
+	cmpl	(%rsi), %ecx
+	je	L(zero)
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+	/* No ymm register was touched.  */
+	ret
+# else
+
+	.p2align 4
+L(between_4_7):
+	/* Load as big endian with overlapping movbe to avoid branches.
+	 */
+	movbe	(%rdi), %eax
+	movbe	(%rsi), %ecx
+	shlq	$32, %rax
+	shlq	$32, %rcx
+	movbe	-4(%rdi, %rdx), %edi
+	movbe	-4(%rsi, %rdx), %esi
+	orq	%rdi, %rax
+	orq	%rsi, %rcx
+	subq	%rcx, %rax
+	jz	L(zero_4_7)
+	sbbl	%eax, %eax
+	orl	$1, %eax
+L(zero_4_7):
+	/* No ymm register was touched.  */
+	ret
+# endif
+
+    .p2align 12
+END (MEMCMP)
+#endif
diff --git a/sysdeps/x86_64/multiarch/bcmp-evex.S b/sysdeps/x86_64/multiarch/bcmp-evex.S
index ce30342210..49fa8812bb 100644
--- a/sysdeps/x86_64/multiarch/bcmp-evex.S
+++ b/sysdeps/x86_64/multiarch/bcmp-evex.S
@@ -1,5 +1,5 @@
-/* bcmp optimized with EVEX
-   Copyright (C) 2017-2021 Free Software Foundation, Inc.
+/* memcmp/wmemcmp optimized with 256-bit EVEX instructions.
+   Copyright (C) 2021 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,8 +16,553 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
+#if IS_IN (libc)
+
+/* memcmp/wmemcmp is implemented as:
+   1. Use ymm vector compares when possible. The only case where
+      vector compares is not possible for when size < CHAR_PER_VEC
+      and loading from either s1 or s2 would cause a page cross.
+   2. For size from 2 to 7 bytes on page cross, load as big endian
+      with movbe and bswap to avoid branches.
+   3. Use xmm vector compare when size >= 4 bytes for memcmp or
+      size >= 8 bytes for wmemcmp.
+   4. Optimistically compare up to first 4 * CHAR_PER_VEC one at a
+      to check for early mismatches. Only do this if its guranteed the
+      work is not wasted.
+   5. If size is 8 * VEC_SIZE or less, unroll the loop.
+   6. Compare 4 * VEC_SIZE at a time with the aligned first memory
+      area.
+   7. Use 2 vector compares when size is 2 * CHAR_PER_VEC or less.
+   8. Use 4 vector compares when size is 4 * CHAR_PER_VEC or less.
+   9. Use 8 vector compares when size is 8 * CHAR_PER_VEC or less.  */
+
+# include <sysdep.h>
+
 # ifndef MEMCMP
 #  define MEMCMP	__bcmp_evex
 # endif
-# define USE_AS_BCMP	1
-#include "memcmp-evex-movbe.S"
+
+# define VMOVU		vmovdqu64
+
+# ifdef USE_AS_WMEMCMP
+#  define CHAR_SIZE	4
+#  define VPCMP	vpcmpd
+# else
+#  define CHAR_SIZE	1
+#  define VPCMP	vpcmpub
+# endif
+
+# define VEC_SIZE	32
+# define PAGE_SIZE	4096
+# define CHAR_PER_VEC	(VEC_SIZE / CHAR_SIZE)
+
+# define XMM0		xmm16
+# define XMM1		xmm17
+# define XMM2		xmm18
+# define YMM0		ymm16
+# define XMM1		xmm17
+# define XMM2		xmm18
+# define YMM1		ymm17
+# define YMM2		ymm18
+# define YMM3		ymm19
+# define YMM4		ymm20
+# define YMM5		ymm21
+# define YMM6		ymm22
+
+/* Warning!
+           wmemcmp has to use SIGNED comparison for elements.
+           memcmp has to use UNSIGNED comparison for elemnts.
+*/
+
+	.section .text.evex,"ax",@progbits
+ENTRY (MEMCMP)
+# ifdef __ILP32__
+	/* Clear the upper 32 bits.  */
+	movl	%edx, %edx
+# endif
+    xorl    %ecx, %ecx
+	cmp	$CHAR_PER_VEC, %RDX_LP
+	jb	L(less_vec)
+
+	/* From VEC to 2 * VEC.  No branch when size == VEC_SIZE.  */
+	VMOVU	(%rsi), %YMM1
+	/* Use compare not equals to directly check for mismatch.  */
+	VPCMP	$4, (%rdi), %YMM1, %k1
+	kmovd	%k1, %eax
+	/* NB: eax must be destination register if going to
+	   L(return_vec_[0,2]). For L(return_vec_3 destination register
+	   must be r8d.  */
+	testl	%eax, %eax
+	jnz	L(return_vec_0)
+
+	cmpq	$(CHAR_PER_VEC * 2), %rdx
+	jbe	L(last_1x_vec)
+
+	/* Check second VEC no matter what.  */
+	VMOVU	VEC_SIZE(%rsi), %YMM2
+	VPCMP	$4, VEC_SIZE(%rdi), %YMM2, %k1
+	kmovd	%k1, %eax
+	testl	%eax, %eax
+	jnz	L(return_vec_1)
+
+	/* Less than 4 * VEC.  */
+	cmpq	$(CHAR_PER_VEC * 4), %rdx
+	jbe	L(last_2x_vec)
+
+	/* Check third and fourth VEC no matter what.  */
+	VMOVU	(VEC_SIZE * 2)(%rsi), %YMM3
+	VPCMP	$4, (VEC_SIZE * 2)(%rdi), %YMM3, %k1
+	kmovd	%k1, %eax
+	testl	%eax, %eax
+	jnz	L(return_vec_2)
+
+	VMOVU	(VEC_SIZE * 3)(%rsi), %YMM4
+	VPCMP	$4, (VEC_SIZE * 3)(%rdi), %YMM4, %k1
+	kmovd	%k1, %r8d
+	testl	%r8d, %r8d
+	jnz	L(return_vec_3)
+
+	/* Zero YMM0. 4x VEC reduction is done with vpxor + vtern so
+	   compare with zero to get a mask is needed.  */
+	vpxorq	%XMM0, %XMM0, %XMM0
+
+	/* Go to 4x VEC loop.  */
+	cmpq	$(CHAR_PER_VEC * 8), %rdx
+	ja	L(more_8x_vec)
+
+	/* Handle remainder of size = 4 * VEC + 1 to 8 * VEC without any
+	   branches.  */
+
+	/* Load first two VEC from s2 before adjusting addresses.  */
+	VMOVU	-(VEC_SIZE * 4)(%rsi, %rdx, CHAR_SIZE), %YMM1
+	VMOVU	-(VEC_SIZE * 3)(%rsi, %rdx, CHAR_SIZE), %YMM2
+	leaq	-(4 * VEC_SIZE)(%rdi, %rdx, CHAR_SIZE), %rdi
+	leaq	-(4 * VEC_SIZE)(%rsi, %rdx, CHAR_SIZE), %rsi
+
+	/* Wait to load from s1 until addressed adjust due to
+	   unlamination of microfusion with complex address mode.  */
+
+	/* vpxor will be all 0s if s1 and s2 are equal. Otherwise it
+	   will have some 1s.  */
+	vpxorq	(%rdi), %YMM1, %YMM1
+	vpxorq	(VEC_SIZE)(%rdi), %YMM2, %YMM2
+
+	VMOVU	(VEC_SIZE * 2)(%rsi), %YMM3
+	vpxorq	(VEC_SIZE * 2)(%rdi), %YMM3, %YMM3
+	/* Or together YMM1, YMM2, and YMM3 into YMM3.  */
+	vpternlogd $0xfe, %YMM1, %YMM2, %YMM3
+
+	VMOVU	(VEC_SIZE * 3)(%rsi), %YMM4
+	/* Ternary logic to xor (VEC_SIZE * 3)(%rdi) with YMM4 while
+	   oring with YMM3. Result is stored in YMM4.  */
+	vpternlogd $0xde, (VEC_SIZE * 3)(%rdi), %YMM3, %YMM4
+	/* Compare YMM4 with 0. If any 1s s1 and s2 don't match.  */
+	VPCMP	$4, %YMM4, %YMM0, %k1
+	kmovd	%k1, %r8d
+	testl	%r8d, %r8d
+	jnz	L(return_vec_0_1_2_3)
+	/* NB: eax must be zero to reach here.  */
+	ret
+
+	/* NB: aligning 32 here allows for the rest of the jump targets
+	   to be tuned for 32 byte alignment. Most important this ensures
+	   the L(more_8x_vec) loop is 32 byte aligned.  */
+	.p2align 5
+L(less_vec):
+	/* Check if one or less CHAR. This is necessary for size = 0 but
+	   is also faster for size = CHAR_SIZE.  */
+	cmpl	$1, %edx
+	jbe	L(one_or_less)
+
+	/* Check if loading one VEC from either s1 or s2 could cause a
+	   page cross. This can have false positives but is by far the
+	   fastest method.  */
+	movl	%edi, %eax
+	orl	%esi, %eax
+	andl	$(PAGE_SIZE - 1), %eax
+	cmpl	$(PAGE_SIZE - VEC_SIZE), %eax
+	jg	L(page_cross_less_vec)
+
+	/* No page cross possible.  */
+	VMOVU	(%rsi), %YMM2
+	VPCMP	$4, (%rdi), %YMM2, %k1
+	kmovd	%k1, %eax
+	/* Create mask in ecx for potentially in bound matches.  */
+	bzhil	%edx, %eax, %eax
+	jnz	L(return_vec_0)
+L(ret0):
+	ret
+
+	.p2align 4
+L(return_vec_0):
+	testl	%ecx, %ecx
+	jz	L(ret0)
+	tzcntl	%eax, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	(%rdi, %rax, CHAR_SIZE), %ecx
+	xorl	%edx, %edx
+	cmpl	(%rsi, %rax, CHAR_SIZE), %ecx
+	/* NB: no partial register stall here because xorl zero idiom
+	   above.  */
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	(%rsi, %rax), %ecx
+	movzbl	(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+	ret
+
+	/* NB: No p2align necessary. Alignment  % 16 is naturally 1
+	   which is good enough for a target not in a loop.  */
+L(return_vec_1):
+	testl	%ecx, %ecx
+	jz	L(ret0)
+	tzcntl	%eax, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	VEC_SIZE(%rdi, %rax, CHAR_SIZE), %ecx
+	xorl	%edx, %edx
+	cmpl	VEC_SIZE(%rsi, %rax, CHAR_SIZE), %ecx
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	VEC_SIZE(%rsi, %rax), %ecx
+	movzbl	VEC_SIZE(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+	ret
+
+	/* NB: No p2align necessary. Alignment  % 16 is naturally 2
+	   which is good enough for a target not in a loop.  */
+L(return_vec_2):
+	testl	%ecx, %ecx
+	jz	L(ret0)
+	tzcntl	%eax, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	(VEC_SIZE * 2)(%rdi, %rax, CHAR_SIZE), %ecx
+	xorl	%edx, %edx
+	cmpl	(VEC_SIZE * 2)(%rsi, %rax, CHAR_SIZE), %ecx
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	(VEC_SIZE * 2)(%rsi, %rax), %ecx
+	movzbl	(VEC_SIZE * 2)(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+	ret
+L(ret_nz):
+	movl	$1, %eax
+	ret
+	.p2align 4
+L(8x_return_vec_0_1_2_3):
+	/* Returning from L(more_8x_vec) requires restoring rsi.  */
+	addq	%rdi, %rsi
+L(return_vec_0_1_2_3):
+	testl	%ecx, %ecx
+	jz	L(ret_nz)
+	VPCMP	$4, %YMM1, %YMM0, %k0
+	kmovd	%k0, %eax
+	testl	%eax, %eax
+	jnz	L(return_vec_0)
+
+	VPCMP	$4, %YMM2, %YMM0, %k0
+	kmovd	%k0, %eax
+	testl	%eax, %eax
+	jnz	L(return_vec_1)
+
+	VPCMP	$4, %YMM3, %YMM0, %k0
+	kmovd	%k0, %eax
+	testl	%eax, %eax
+	jnz	L(return_vec_2)
+L(return_vec_3):
+	testl	%ecx, %ecx
+	jz	L(ret_nz)
+	tzcntl	%r8d, %r8d
+# ifdef USE_AS_WMEMCMP
+	movl	(VEC_SIZE * 3)(%rdi, %r8, CHAR_SIZE), %eax
+	xorl	%edx, %edx
+	cmpl	(VEC_SIZE * 3)(%rsi, %r8, CHAR_SIZE), %eax
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	(VEC_SIZE * 3)(%rdi, %r8), %eax
+	movzbl	(VEC_SIZE * 3)(%rsi, %r8), %ecx
+	subl	%ecx, %eax
+# endif
+	ret
+
+	.p2align 4
+L(more_8x_vec):
+	/* Set end of s1 in rdx.  */
+	leaq	-(VEC_SIZE * 4)(%rdi, %rdx, CHAR_SIZE), %rdx
+	/* rsi stores s2 - s1. This allows loop to only update one
+	   pointer.  */
+	subq	%rdi, %rsi
+	/* Align s1 pointer.  */
+	andq	$-VEC_SIZE, %rdi
+	/* Adjust because first 4x vec where check already.  */
+	subq	$-(VEC_SIZE * 4), %rdi
+	.p2align 4
+L(loop_4x_vec):
+	VMOVU	(%rsi, %rdi), %YMM1
+	vpxorq	(%rdi), %YMM1, %YMM1
+
+	VMOVU	VEC_SIZE(%rsi, %rdi), %YMM2
+	vpxorq	VEC_SIZE(%rdi), %YMM2, %YMM2
+
+	VMOVU	(VEC_SIZE * 2)(%rsi, %rdi), %YMM3
+	vpxorq	(VEC_SIZE * 2)(%rdi), %YMM3, %YMM3
+	vpternlogd $0xfe, %YMM1, %YMM2, %YMM3
+
+	VMOVU	(VEC_SIZE * 3)(%rsi, %rdi), %YMM4
+	vpternlogd $0xde, (VEC_SIZE * 3)(%rdi), %YMM3, %YMM4
+	VPCMP	$4, %YMM4, %YMM0, %k1
+	kmovd	%k1, %r8d
+	testl	%r8d, %r8d
+	jnz	L(8x_return_vec_0_1_2_3)
+	subq	$-(VEC_SIZE * 4), %rdi
+	cmpq	%rdx, %rdi
+	jb	L(loop_4x_vec)
+
+	subq	%rdx, %rdi
+	/* rdi has 4 * VEC_SIZE - remaining length.  */
+	cmpl	$(VEC_SIZE * 3), %edi
+	jae	L(8x_last_1x_vec)
+	/* Load regardless of branch.  */
+	VMOVU	(VEC_SIZE * 2)(%rsi, %rdx), %YMM3
+	cmpl	$(VEC_SIZE * 2), %edi
+	jae	L(8x_last_2x_vec)
+
+	VMOVU	(%rsi, %rdx), %YMM1
+	vpxorq	(%rdx), %YMM1, %YMM1
+
+	VMOVU	VEC_SIZE(%rsi, %rdx), %YMM2
+	vpxorq	VEC_SIZE(%rdx), %YMM2, %YMM2
+
+	vpxorq	(VEC_SIZE * 2)(%rdx), %YMM3, %YMM3
+	vpternlogd $0xfe, %YMM1, %YMM2, %YMM3
+
+	VMOVU	(VEC_SIZE * 3)(%rsi, %rdx), %YMM4
+	vpternlogd $0xde, (VEC_SIZE * 3)(%rdx), %YMM3, %YMM4
+	VPCMP	$4, %YMM4, %YMM0, %k1
+	kmovd	%k1, %r8d
+	/* Restore s1 pointer to rdi.  */
+	movq	%rdx, %rdi
+	testl	%r8d, %r8d
+	jnz	L(8x_return_vec_0_1_2_3)
+	/* NB: eax must be zero to reach here.  */
+	ret
+
+	/* Only entry is from L(more_8x_vec).  */
+	.p2align 4
+L(8x_last_2x_vec):
+	VPCMP	$4, (VEC_SIZE * 2)(%rdx), %YMM3, %k1
+	kmovd	%k1, %eax
+	testl	%eax, %eax
+	jnz	L(8x_return_vec_2)
+	/* Naturally aligned to 16 bytes.  */
+L(8x_last_1x_vec):
+	VMOVU	(VEC_SIZE * 3)(%rsi, %rdx), %YMM1
+	VPCMP	$4, (VEC_SIZE * 3)(%rdx), %YMM1, %k1
+	kmovd	%k1, %eax
+	testl	%eax, %eax
+	jnz	L(8x_return_vec_3)
+	ret
+
+	.p2align 4
+L(last_2x_vec):
+	/* Check second to last VEC.  */
+	VMOVU	-(VEC_SIZE * 2)(%rsi, %rdx, CHAR_SIZE), %YMM1
+	VPCMP	$4, -(VEC_SIZE * 2)(%rdi, %rdx, CHAR_SIZE), %YMM1, %k1
+	kmovd	%k1, %eax
+	testl	%eax, %eax
+	jnz	L(return_vec_1_end)
+
+	/* Check last VEC.  */
+	.p2align 4
+L(last_1x_vec):
+	VMOVU	-(VEC_SIZE * 1)(%rsi, %rdx, CHAR_SIZE), %YMM1
+	VPCMP	$4, -(VEC_SIZE * 1)(%rdi, %rdx, CHAR_SIZE), %YMM1, %k1
+	kmovd	%k1, %eax
+	testl	%eax, %eax
+	jnz	L(return_vec_0_end)
+	ret
+
+	.p2align 4
+L(8x_return_vec_2):
+	subq	$VEC_SIZE, %rdx
+L(8x_return_vec_3):
+	testl	%ecx, %ecx
+	jz	L(ret1)
+	tzcntl	%eax, %eax
+# ifdef USE_AS_WMEMCMP
+	leaq	(%rdx, %rax, CHAR_SIZE), %rax
+	movl	(VEC_SIZE * 3)(%rax), %ecx
+	xorl	%edx, %edx
+	cmpl	(VEC_SIZE * 3)(%rsi, %rax), %ecx
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	addq	%rdx, %rax
+	movzbl	(VEC_SIZE * 3)(%rsi, %rax), %ecx
+	movzbl	(VEC_SIZE * 3)(%rax), %eax
+	subl	%ecx, %eax
+# endif
+L(ret1):
+	ret
+
+	.p2align 4
+L(return_vec_0_end):
+	testl	%ecx, %ecx
+	jz	L(ret1)
+	tzcntl	%eax, %eax
+	addl	%edx, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	-VEC_SIZE(%rdi, %rax, CHAR_SIZE), %ecx
+	xorl	%edx, %edx
+	cmpl	-VEC_SIZE(%rsi, %rax, CHAR_SIZE), %ecx
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	-VEC_SIZE(%rsi, %rax), %ecx
+	movzbl	-VEC_SIZE(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+	ret
+
+	.p2align 4
+L(return_vec_1_end):
+	testl	%ecx, %ecx
+	jz	L(ret1)
+	tzcntl	%eax, %eax
+	addl	%edx, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	-(VEC_SIZE * 2)(%rdi, %rax, CHAR_SIZE), %ecx
+	xorl	%edx, %edx
+	cmpl	-(VEC_SIZE * 2)(%rsi, %rax, CHAR_SIZE), %ecx
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	-(VEC_SIZE * 2)(%rsi, %rax), %ecx
+	movzbl	-(VEC_SIZE * 2)(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+	ret
+
+
+	.p2align 4
+L(page_cross_less_vec):
+	/* if USE_AS_WMEMCMP it can only be 0, 4, 8, 12, 16, 20, 24, 28
+	   bytes.  */
+	cmpl	$(16 / CHAR_SIZE), %edx
+	jae	L(between_16_31)
+# ifndef USE_AS_WMEMCMP
+	cmpl	$8, %edx
+	jae	L(between_8_15)
+	cmpl	$4, %edx
+	jae	L(between_4_7)
+L(between_2_3):
+	/* Load as big endian to avoid branches.  */
+	movzwl	(%rdi), %eax
+	movzwl	(%rsi), %ecx
+	shll	$8, %eax
+	shll	$8, %ecx
+	bswap	%eax
+	bswap	%ecx
+	movzbl	-1(%rdi, %rdx), %edi
+	movzbl	-1(%rsi, %rdx), %esi
+	orl	%edi, %eax
+	orl	%esi, %ecx
+	/* Subtraction is okay because the upper 8 bits are zero.  */
+	subl	%ecx, %eax
+	ret
+	.p2align 4
+L(one_or_less):
+	jb	L(zero)
+	movzbl	(%rsi), %ecx
+	movzbl	(%rdi), %eax
+	subl	%ecx, %eax
+	ret
+
+	.p2align 4
+L(between_8_15):
+# endif
+	/* If USE_AS_WMEMCMP fall through into 8-15 byte case.  */
+	vmovq	(%rdi), %XMM1
+	vmovq	(%rsi), %XMM2
+	VPCMP	$4, %XMM1, %XMM2, %k1
+	kmovd	%k1, %eax
+	testl	%eax, %eax
+	jnz	L(return_vec_0)
+	/* Use overlapping loads to avoid branches.  */
+	leaq	-8(%rdi, %rdx, CHAR_SIZE), %rdi
+	leaq	-8(%rsi, %rdx, CHAR_SIZE), %rsi
+	vmovq	(%rdi), %XMM1
+	vmovq	(%rsi), %XMM2
+	VPCMP	$4, %XMM1, %XMM2, %k1
+	kmovd	%k1, %eax
+	testl	%eax, %eax
+	jnz	L(return_vec_0)
+	ret
+
+	.p2align 4
+L(zero):
+	xorl	%eax, %eax
+	ret
+
+	.p2align 4
+L(between_16_31):
+	/* From 16 to 31 bytes.  No branch when size == 16.  */
+	VMOVU	(%rsi), %XMM2
+	VPCMP	$4, (%rdi), %XMM2, %k1
+	kmovd	%k1, %eax
+	testl	%eax, %eax
+	jnz	L(return_vec_0)
+
+	/* Use overlapping loads to avoid branches.  */
+
+	VMOVU	-16(%rsi, %rdx, CHAR_SIZE), %XMM2
+	leaq	-16(%rdi, %rdx, CHAR_SIZE), %rdi
+	leaq	-16(%rsi, %rdx, CHAR_SIZE), %rsi
+	VPCMP	$4, (%rdi), %XMM2, %k1
+	kmovd	%k1, %eax
+	testl	%eax, %eax
+	jnz	L(return_vec_0)
+	ret
+
+# ifdef USE_AS_WMEMCMP
+	.p2align 4
+L(one_or_less):
+	jb	L(zero)
+	movl	(%rdi), %ecx
+	xorl	%edx, %edx
+	cmpl	(%rsi), %ecx
+	je	L(zero)
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+	ret
+# else
+
+	.p2align 4
+L(between_4_7):
+	/* Load as big endian with overlapping movbe to avoid branches.
+	 */
+	movbe	(%rdi), %eax
+	movbe	(%rsi), %ecx
+	shlq	$32, %rax
+	shlq	$32, %rcx
+	movbe	-4(%rdi, %rdx), %edi
+	movbe	-4(%rsi, %rdx), %esi
+	orq	%rdi, %rax
+	orq	%rsi, %rcx
+	subq	%rcx, %rax
+	jz	L(zero_4_7)
+	sbbl	%eax, %eax
+	orl	$1, %eax
+L(zero_4_7):
+	ret
+# endif
+
+    .p2align 12
+END (MEMCMP)
+#endif
diff --git a/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S b/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
index 231d69c9a8..dc5986006f 100644
--- a/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
+++ b/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
@@ -75,6 +75,7 @@ ENTRY (MEMCMP)
 	/* Clear the upper 32 bits.  */
 	movl	%edx, %edx
 # endif
+	movl	$1, %ecx
 	cmp	$VEC_SIZE, %RDX_LP
 	jb	L(less_vec)
 
@@ -112,8 +113,8 @@ ENTRY (MEMCMP)
 	jnz	L(return_vec_2)
 	vmovdqu	(VEC_SIZE * 3)(%rsi), %ymm4
 	VPCMPEQ	(VEC_SIZE * 3)(%rdi), %ymm4, %ymm4
-	vpmovmskb %ymm4, %ecx
-	incl	%ecx
+	vpmovmskb %ymm4, %r8d
+	incl	%r8d
 	jnz	L(return_vec_3)
 
 	/* Go to 4x VEC loop.  */
@@ -143,14 +144,17 @@ ENTRY (MEMCMP)
 	vpand	%ymm1, %ymm2, %ymm5
 	vpand	%ymm3, %ymm4, %ymm6
 	vpand	%ymm5, %ymm6, %ymm7
-	vpmovmskb %ymm7, %ecx
-	incl	%ecx
+	vpmovmskb %ymm7, %r8d
+	incl	%r8d
 	jnz	L(return_vec_0_1_2_3)
 	/* NB: eax must be zero to reach here.  */
+L(ret0):
 	VZEROUPPER_RETURN
 
 	.p2align 4
 L(return_vec_0):
+	testl	%ecx, %ecx
+	jz	L(ret0)
 	tzcntl	%eax, %eax
 # ifdef USE_AS_WMEMCMP
 	movl	(%rdi, %rax), %ecx
@@ -170,6 +174,8 @@ L(return_vzeroupper):
 
 	.p2align 4
 L(return_vec_1):
+	testl	%ecx, %ecx
+	jz	L(ret0)
 	tzcntl	%eax, %eax
 # ifdef USE_AS_WMEMCMP
 	movl	VEC_SIZE(%rdi, %rax), %ecx
@@ -186,6 +192,8 @@ L(return_vec_1):
 
 	.p2align 4
 L(return_vec_2):
+	testl	%ecx, %ecx
+	jz	L(ret0)
 	tzcntl	%eax, %eax
 # ifdef USE_AS_WMEMCMP
 	movl	(VEC_SIZE * 2)(%rdi, %rax), %ecx
@@ -199,6 +207,9 @@ L(return_vec_2):
 	subl	%ecx, %eax
 # endif
 	VZEROUPPER_RETURN
+L(ret_nz):
+	movl	$1, %eax
+	VZEROUPPER_RETURN
 
 	/* NB: p2align 5 here to ensure 4x loop is 32 byte aligned.  */
 	.p2align 5
@@ -206,6 +217,9 @@ L(8x_return_vec_0_1_2_3):
 	/* Returning from L(more_8x_vec) requires restoring rsi.  */
 	addq	%rdi, %rsi
 L(return_vec_0_1_2_3):
+	testl	%ecx, %ecx
+	jz	L(ret_nz)
+
 	vpmovmskb %ymm1, %eax
 	incl	%eax
 	jnz	L(return_vec_0)
@@ -218,16 +232,18 @@ L(return_vec_0_1_2_3):
 	incl	%eax
 	jnz	L(return_vec_2)
 L(return_vec_3):
-	tzcntl	%ecx, %ecx
+	testl	%ecx, %ecx
+	jz	L(ret_nz)
+	tzcntl	%r8d, %r8d
 # ifdef USE_AS_WMEMCMP
-	movl	(VEC_SIZE * 3)(%rdi, %rcx), %eax
+	movl	(VEC_SIZE * 3)(%rdi, %r8), %eax
 	xorl	%edx, %edx
-	cmpl	(VEC_SIZE * 3)(%rsi, %rcx), %eax
+	cmpl	(VEC_SIZE * 3)(%rsi, %r8), %eax
 	setg	%dl
 	leal	-1(%rdx, %rdx), %eax
 # else
-	movzbl	(VEC_SIZE * 3)(%rdi, %rcx), %eax
-	movzbl	(VEC_SIZE * 3)(%rsi, %rcx), %ecx
+	movzbl	(VEC_SIZE * 3)(%rdi, %r8), %eax
+	movzbl	(VEC_SIZE * 3)(%rsi, %r8), %ecx
 	subl	%ecx, %eax
 # endif
 	VZEROUPPER_RETURN
@@ -262,8 +278,8 @@ L(loop_4x_vec):
 	vpand	%ymm1, %ymm2, %ymm5
 	vpand	%ymm3, %ymm4, %ymm6
 	vpand	%ymm5, %ymm6, %ymm7
-	vpmovmskb %ymm7, %ecx
-	incl	%ecx
+	vpmovmskb %ymm7, %r8d
+	incl	%r8d
 	jnz	L(8x_return_vec_0_1_2_3)
 	subq	$-(VEC_SIZE * 4), %rdi
 	/* Check if s1 pointer at end.  */
@@ -294,10 +310,10 @@ L(loop_4x_vec):
 	vpand	%ymm1, %ymm2, %ymm5
 	vpand	%ymm3, %ymm4, %ymm6
 	vpand	%ymm5, %ymm6, %ymm7
-	vpmovmskb %ymm7, %ecx
+	vpmovmskb %ymm7, %r8d
 	/* Restore s1 pointer to rdi.  */
 	movq	%rdx, %rdi
-	incl	%ecx
+	incl	%r8d
 	jnz	L(8x_return_vec_0_1_2_3)
 	/* NB: eax must be zero to reach here.  */
 	VZEROUPPER_RETURN
@@ -343,6 +359,9 @@ L(last_1x_vec):
 L(8x_return_vec_2):
 	subq	$VEC_SIZE, %rdx
 L(8x_return_vec_3):
+	testl	%ecx, %ecx
+	jz	L(ret1)
+
 	tzcntl	%eax, %eax
 	addq	%rdx, %rax
 # ifdef USE_AS_WMEMCMP
@@ -356,10 +375,13 @@ L(8x_return_vec_3):
 	movzbl	(VEC_SIZE * 3)(%rax), %eax
 	subl	%ecx, %eax
 # endif
+L(ret1):
 	VZEROUPPER_RETURN
 
 	.p2align 4
 L(return_vec_1_end):
+	testl	%ecx, %ecx
+	jz	L(ret1)
 	tzcntl	%eax, %eax
 	addl	%edx, %eax
 # ifdef USE_AS_WMEMCMP
@@ -377,6 +399,8 @@ L(return_vec_1_end):
 
 	.p2align 4
 L(return_vec_0_end):
+	testl	%ecx, %ecx
+	jz	L(ret1)
 	tzcntl	%eax, %eax
 	addl	%edx, %eax
 # ifdef USE_AS_WMEMCMP
diff --git a/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S b/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S
index 06cecda5a3..8f765bc87b 100644
--- a/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S
+++ b/sysdeps/x86_64/multiarch/memcmp-evex-movbe.S
@@ -80,6 +80,7 @@ ENTRY (MEMCMP)
 	/* Clear the upper 32 bits.  */
 	movl	%edx, %edx
 # endif
+	movl	$1, %ecx
 	cmp	$CHAR_PER_VEC, %RDX_LP
 	jb	L(less_vec)
 
@@ -90,7 +91,7 @@ ENTRY (MEMCMP)
 	kmovd	%k1, %eax
 	/* NB: eax must be destination register if going to
 	   L(return_vec_[0,2]). For L(return_vec_3 destination register
-	   must be ecx.  */
+	   must be r8d.  */
 	testl	%eax, %eax
 	jnz	L(return_vec_0)
 
@@ -117,8 +118,8 @@ ENTRY (MEMCMP)
 
 	VMOVU	(VEC_SIZE * 3)(%rsi), %YMM4
 	VPCMP	$4, (VEC_SIZE * 3)(%rdi), %YMM4, %k1
-	kmovd	%k1, %ecx
-	testl	%ecx, %ecx
+	kmovd	%k1, %r8d
+	testl	%r8d, %r8d
 	jnz	L(return_vec_3)
 
 	/* Zero YMM0. 4x VEC reduction is done with vpxor + vtern so
@@ -157,8 +158,8 @@ ENTRY (MEMCMP)
 	vpternlogd $0xde, (VEC_SIZE * 3)(%rdi), %YMM3, %YMM4
 	/* Compare YMM4 with 0. If any 1s s1 and s2 don't match.  */
 	VPCMP	$4, %YMM4, %YMM0, %k1
-	kmovd	%k1, %ecx
-	testl	%ecx, %ecx
+	kmovd	%k1, %r8d
+	testl	%r8d, %r8d
 	jnz	L(return_vec_0_1_2_3)
 	/* NB: eax must be zero to reach here.  */
 	ret
@@ -189,10 +190,13 @@ L(less_vec):
 	/* Create mask in ecx for potentially in bound matches.  */
 	bzhil	%edx, %eax, %eax
 	jnz	L(return_vec_0)
+L(ret0):
 	ret
 
 	.p2align 4
 L(return_vec_0):
+	testl	%ecx, %ecx
+	jz	L(ret0)
 	tzcntl	%eax, %eax
 # ifdef USE_AS_WMEMCMP
 	movl	(%rdi, %rax, CHAR_SIZE), %ecx
@@ -212,6 +216,8 @@ L(return_vec_0):
 	/* NB: No p2align necessary. Alignment  % 16 is naturally 1
 	   which is good enough for a target not in a loop.  */
 L(return_vec_1):
+	testl	%ecx, %ecx
+	jz	L(ret0)
 	tzcntl	%eax, %eax
 # ifdef USE_AS_WMEMCMP
 	movl	VEC_SIZE(%rdi, %rax, CHAR_SIZE), %ecx
@@ -229,6 +235,8 @@ L(return_vec_1):
 	/* NB: No p2align necessary. Alignment  % 16 is naturally 2
 	   which is good enough for a target not in a loop.  */
 L(return_vec_2):
+	testl	%ecx, %ecx
+	jz	L(ret0)
 	tzcntl	%eax, %eax
 # ifdef USE_AS_WMEMCMP
 	movl	(VEC_SIZE * 2)(%rdi, %rax, CHAR_SIZE), %ecx
@@ -242,12 +250,16 @@ L(return_vec_2):
 	subl	%ecx, %eax
 # endif
 	ret
-
+L(ret_nz):
+	movl	$1, %eax
+	ret
 	.p2align 4
 L(8x_return_vec_0_1_2_3):
 	/* Returning from L(more_8x_vec) requires restoring rsi.  */
 	addq	%rdi, %rsi
 L(return_vec_0_1_2_3):
+	testl	%ecx, %ecx
+	jz	L(ret_nz)
 	VPCMP	$4, %YMM1, %YMM0, %k0
 	kmovd	%k0, %eax
 	testl	%eax, %eax
@@ -263,16 +275,18 @@ L(return_vec_0_1_2_3):
 	testl	%eax, %eax
 	jnz	L(return_vec_2)
 L(return_vec_3):
-	tzcntl	%ecx, %ecx
+	testl	%ecx, %ecx
+	jz	L(ret_nz)
+	tzcntl	%r8d, %r8d
 # ifdef USE_AS_WMEMCMP
-	movl	(VEC_SIZE * 3)(%rdi, %rcx, CHAR_SIZE), %eax
+	movl	(VEC_SIZE * 3)(%rdi, %r8, CHAR_SIZE), %eax
 	xorl	%edx, %edx
-	cmpl	(VEC_SIZE * 3)(%rsi, %rcx, CHAR_SIZE), %eax
+	cmpl	(VEC_SIZE * 3)(%rsi, %r8, CHAR_SIZE), %eax
 	setg	%dl
 	leal	-1(%rdx, %rdx), %eax
 # else
-	movzbl	(VEC_SIZE * 3)(%rdi, %rcx), %eax
-	movzbl	(VEC_SIZE * 3)(%rsi, %rcx), %ecx
+	movzbl	(VEC_SIZE * 3)(%rdi, %r8), %eax
+	movzbl	(VEC_SIZE * 3)(%rsi, %r8), %ecx
 	subl	%ecx, %eax
 # endif
 	ret
@@ -303,8 +317,8 @@ L(loop_4x_vec):
 	VMOVU	(VEC_SIZE * 3)(%rsi, %rdi), %YMM4
 	vpternlogd $0xde, (VEC_SIZE * 3)(%rdi), %YMM3, %YMM4
 	VPCMP	$4, %YMM4, %YMM0, %k1
-	kmovd	%k1, %ecx
-	testl	%ecx, %ecx
+	kmovd	%k1, %r8d
+	testl	%r8d, %r8d
 	jnz	L(8x_return_vec_0_1_2_3)
 	subq	$-(VEC_SIZE * 4), %rdi
 	cmpq	%rdx, %rdi
@@ -331,10 +345,10 @@ L(loop_4x_vec):
 	VMOVU	(VEC_SIZE * 3)(%rsi, %rdx), %YMM4
 	vpternlogd $0xde, (VEC_SIZE * 3)(%rdx), %YMM3, %YMM4
 	VPCMP	$4, %YMM4, %YMM0, %k1
-	kmovd	%k1, %ecx
+	kmovd	%k1, %r8d
 	/* Restore s1 pointer to rdi.  */
 	movq	%rdx, %rdi
-	testl	%ecx, %ecx
+	testl	%r8d, %r8d
 	jnz	L(8x_return_vec_0_1_2_3)
 	/* NB: eax must be zero to reach here.  */
 	ret
@@ -378,6 +392,8 @@ L(last_1x_vec):
 L(8x_return_vec_2):
 	subq	$VEC_SIZE, %rdx
 L(8x_return_vec_3):
+	testl	%ecx, %ecx
+	jz	L(ret1)
 	tzcntl	%eax, %eax
 # ifdef USE_AS_WMEMCMP
 	leaq	(%rdx, %rax, CHAR_SIZE), %rax
@@ -392,10 +408,13 @@ L(8x_return_vec_3):
 	movzbl	(VEC_SIZE * 3)(%rax), %eax
 	subl	%ecx, %eax
 # endif
+L(ret1):
 	ret
 
 	.p2align 4
 L(return_vec_0_end):
+	testl	%ecx, %ecx
+	jz	L(ret1)
 	tzcntl	%eax, %eax
 	addl	%edx, %eax
 # ifdef USE_AS_WMEMCMP
@@ -413,6 +432,8 @@ L(return_vec_0_end):
 
 	.p2align 4
 L(return_vec_1_end):
+	testl	%ecx, %ecx
+	jz	L(ret1)
 	tzcntl	%eax, %eax
 	addl	%edx, %eax
 # ifdef USE_AS_WMEMCMP
-- 
2.25.1

