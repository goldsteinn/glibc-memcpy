From 3c10eb8117727bc4636741acfefc613f2b2359c1 Mon Sep 17 00:00:00 2001
From: Noah Goldstein <goldstein.w.n@gmail.com>
Date: Thu, 7 Oct 2021 19:41:12 -0500
Subject: [PATCH 11/11] tmp

---
 sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S | 385 ++++++++++---------
 1 file changed, 198 insertions(+), 187 deletions(-)

diff --git a/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S b/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
index 231d69c9a8..fcfd9f2270 100644
--- a/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
+++ b/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
@@ -86,11 +86,127 @@ ENTRY (MEMCMP)
 	   L(return_vec_[0,2]). For L(return_vec_3 destination register
 	   must be ecx.  */
 	incl	%eax
-	jnz	L(return_vec_0)
+	jnz	L(return_vec_0_start)
 
 	cmpq	$(VEC_SIZE * 2), %rdx
-	jbe	L(last_1x_vec)
+	ja	L(more_2x_vec)
+	vmovdqu	-(VEC_SIZE * 1)(%rsi, %rdx), %ymm1
+	VPCMPEQ	-(VEC_SIZE * 1)(%rdi, %rdx), %ymm1, %ymm1
+	vpmovmskb %ymm1, %eax
+	incl	%eax
+	jnz	L(return_vec_0_end)
+	VZEROUPPER_RETURN
+
 
+	.p2align 4,, 12
+L(return_vec_0_start):
+	bsfl	%eax, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	(%rdi, %rax), %ecx
+	xorl	%edx, %edx
+	cmpl	(%rsi, %rax), %ecx
+	/* NB: no partial register stall here because xorl zero idiom
+	   above.  */
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	(%rsi, %rax), %ecx
+	movzbl	(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+	VZEROUPPER_RETURN
+
+	.p2align 4
+L(return_vec_1_end):
+	subl	$VEC_SIZE, %edx
+L(return_vec_0_end):
+	bsfl	%eax, %eax
+	addl	%edx, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	-VEC_SIZE(%rdi, %rax), %ecx
+	xorl	%edx, %edx
+	cmpl	-VEC_SIZE(%rsi, %rax), %ecx
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	-VEC_SIZE(%rsi, %rax), %ecx
+	movzbl	-VEC_SIZE(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+	VZEROUPPER_RETURN
+
+	.p2align 4
+L(less_vec):
+	/* Check if one or less CHAR. This is necessary for size = 0 but
+	   is also faster for size = CHAR_SIZE.  */
+	cmpl	$CHAR_SIZE, %edx
+	jbe	L(one_or_less)
+
+	/* Check if loading one VEC from either s1 or s2 could cause a
+	   page cross. This can have false positives but is by far the
+	   fastest method.  */
+	movl	%edi, %eax
+	orl	%esi, %eax
+	andl	$(PAGE_SIZE - 1), %eax
+	cmpl	$(PAGE_SIZE - VEC_SIZE), %eax
+	ja	L(page_cross_less_vec)
+
+	/* No page cross possible.  */
+	vmovdqu	(%rsi), %ymm2
+	VPCMPEQ	(%rdi), %ymm2, %ymm2
+	vpmovmskb %ymm2, %eax
+	incl	%eax
+	/* Result will be zero if s1 and s2 match. Otherwise first set
+	   bit will be first mismatch.  */
+	bzhil	%edx, %eax, %eax
+	jnz	L(return_vec_0_start)
+	VZEROUPPER_RETURN
+	.p2align 4,, 10
+# ifdef USE_AS_WMEMCMP
+L(one_or_less):
+	jb	L(zero)
+	movl	(%rdi), %ecx
+	xorl	%edx, %edx
+	cmpl	(%rsi), %ecx
+	je	L(zero)
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+	/* No ymm register was touched.  */
+	ret
+# else
+L(one_or_less):
+	jb	L(zero)
+	movzbl	(%rsi), %ecx
+	movzbl	(%rdi), %eax
+	subl	%ecx, %eax
+	/* No ymm register was touched.  */
+	ret
+# endif
+
+L(zero):
+	xorl	%eax, %eax
+	ret
+    
+    
+	.p2align 4
+L(last_2x_vec):
+	/* Check second to last VEC.  */
+	vmovdqu	-(VEC_SIZE * 2)(%rsi, %rdx), %ymm1
+	VPCMPEQ	-(VEC_SIZE * 2)(%rdi, %rdx), %ymm1, %ymm1
+	vpmovmskb %ymm1, %eax
+	incl	%eax
+	jnz	L(return_vec_1_end)
+	/* Check last VEC.  */
+	vmovdqu	-(VEC_SIZE * 1)(%rsi, %rdx), %ymm1
+	VPCMPEQ	-(VEC_SIZE * 1)(%rdi, %rdx), %ymm1, %ymm1
+	vpmovmskb %ymm1, %eax
+	incl	%eax
+	jnz	L(return_vec_0_end)
+	VZEROUPPER_RETURN
+
+
+	.p2align 4
+L(more_2x_vec):
 	/* Check second VEC no matter what.  */
 	vmovdqu	VEC_SIZE(%rsi), %ymm2
 	VPCMPEQ	VEC_SIZE(%rdi), %ymm2, %ymm2
@@ -149,9 +265,26 @@ ENTRY (MEMCMP)
 	/* NB: eax must be zero to reach here.  */
 	VZEROUPPER_RETURN
 
-	.p2align 4
+
+	.p2align 4,, 6
+L(return_vec_2):
+	bsfl	%eax, %eax
+# ifdef USE_AS_WMEMCMP
+	movl	(VEC_SIZE * 2)(%rdi, %rax), %ecx
+	xorl	%edx, %edx
+	cmpl	(VEC_SIZE * 2)(%rsi, %rax), %ecx
+	setg	%dl
+	leal	-1(%rdx, %rdx), %eax
+# else
+	movzbl	(VEC_SIZE * 2)(%rsi, %rax), %ecx
+	movzbl	(VEC_SIZE * 2)(%rdi, %rax), %eax
+	subl	%ecx, %eax
+# endif
+	VZEROUPPER_RETURN
+    
+	.p2align 4,, 12
 L(return_vec_0):
-	tzcntl	%eax, %eax
+	bsfl	%eax, %eax
 # ifdef USE_AS_WMEMCMP
 	movl	(%rdi, %rax), %ecx
 	xorl	%edx, %edx
@@ -165,12 +298,11 @@ L(return_vec_0):
 	movzbl	(%rdi, %rax), %eax
 	subl	%ecx, %eax
 # endif
-L(return_vzeroupper):
-	ZERO_UPPER_VEC_REGISTERS_RETURN
+	VZEROUPPER_RETURN
 
-	.p2align 4
+	.p2align 4,, 12
 L(return_vec_1):
-	tzcntl	%eax, %eax
+	bsfl	%eax, %eax
 # ifdef USE_AS_WMEMCMP
 	movl	VEC_SIZE(%rdi, %rax), %ecx
 	xorl	%edx, %edx
@@ -184,24 +316,9 @@ L(return_vec_1):
 # endif
 	VZEROUPPER_RETURN
 
-	.p2align 4
-L(return_vec_2):
-	tzcntl	%eax, %eax
-# ifdef USE_AS_WMEMCMP
-	movl	(VEC_SIZE * 2)(%rdi, %rax), %ecx
-	xorl	%edx, %edx
-	cmpl	(VEC_SIZE * 2)(%rsi, %rax), %ecx
-	setg	%dl
-	leal	-1(%rdx, %rdx), %eax
-# else
-	movzbl	(VEC_SIZE * 2)(%rsi, %rax), %ecx
-	movzbl	(VEC_SIZE * 2)(%rdi, %rax), %eax
-	subl	%ecx, %eax
-# endif
-	VZEROUPPER_RETURN
 
-	/* NB: p2align 5 here to ensure 4x loop is 32 byte aligned.  */
-	.p2align 5
+
+	.p2align 4
 L(8x_return_vec_0_1_2_3):
 	/* Returning from L(more_8x_vec) requires restoring rsi.  */
 	addq	%rdi, %rsi
@@ -217,6 +334,8 @@ L(return_vec_0_1_2_3):
 	vpmovmskb %ymm3, %eax
 	incl	%eax
 	jnz	L(return_vec_2)
+
+	.p2align 4,, 4
 L(return_vec_3):
 	tzcntl	%ecx, %ecx
 # ifdef USE_AS_WMEMCMP
@@ -230,8 +349,10 @@ L(return_vec_3):
 	movzbl	(VEC_SIZE * 3)(%rsi, %rcx), %ecx
 	subl	%ecx, %eax
 # endif
-	VZEROUPPER_RETURN
+L(return_vzeroupper):
+	ZERO_UPPER_VEC_REGISTERS_RETURN
 
+    
 	.p2align 4
 L(more_8x_vec):
 	/* Set end of s1 in rdx.  */
@@ -274,11 +395,16 @@ L(loop_4x_vec):
 	/* rdi has 4 * VEC_SIZE - remaining length.  */
 	cmpl	$(VEC_SIZE * 3), %edi
 	jae	L(8x_last_1x_vec)
+
 	/* Load regardless of branch.  */
 	vmovdqu	(VEC_SIZE * 2)(%rsi, %rdx), %ymm3
+	VPCMPEQ	(VEC_SIZE * 2)(%rdx), %ymm3, %ymm3
 	cmpl	$(VEC_SIZE * 2), %edi
 	jae	L(8x_last_2x_vec)
 
+	vmovdqu	(VEC_SIZE * 3)(%rsi, %rdx), %ymm4
+	VPCMPEQ	(VEC_SIZE * 3)(%rdx), %ymm4, %ymm4
+
 	/* Check last 4 VEC.  */
 	vmovdqu	(%rsi, %rdx), %ymm1
 	VPCMPEQ	(%rdx), %ymm1, %ymm1
@@ -286,10 +412,6 @@ L(loop_4x_vec):
 	vmovdqu	VEC_SIZE(%rsi, %rdx), %ymm2
 	VPCMPEQ	VEC_SIZE(%rdx), %ymm2, %ymm2
 
-	VPCMPEQ	(VEC_SIZE * 2)(%rdx), %ymm3, %ymm3
-
-	vmovdqu	(VEC_SIZE * 3)(%rsi, %rdx), %ymm4
-	VPCMPEQ	(VEC_SIZE * 3)(%rdx), %ymm4, %ymm4
 
 	vpand	%ymm1, %ymm2, %ymm5
 	vpand	%ymm3, %ymm4, %ymm6
@@ -303,17 +425,17 @@ L(loop_4x_vec):
 	VZEROUPPER_RETURN
 
 	/* Only entry is from L(more_8x_vec).  */
-	.p2align 4
+	.p2align 4,, 10
 L(8x_last_2x_vec):
 	/* Check second to last VEC. rdx store end pointer of s1 and
 	   ymm3 has already been loaded with second to last VEC from s2.
 	 */
-	VPCMPEQ	(VEC_SIZE * 2)(%rdx), %ymm3, %ymm3
+
 	vpmovmskb %ymm3, %eax
 	incl	%eax
 	jnz	L(8x_return_vec_2)
 	/* Check last VEC.  */
-	.p2align 4
+	.p2align 4,, 6
 L(8x_last_1x_vec):
 	vmovdqu	(VEC_SIZE * 3)(%rsi, %rdx), %ymm4
 	VPCMPEQ	(VEC_SIZE * 3)(%rdx), %ymm4, %ymm4
@@ -321,24 +443,7 @@ L(8x_last_1x_vec):
 	incl	%eax
 	jnz	L(8x_return_vec_3)
 	VZEROUPPER_RETURN
-
-	.p2align 4
-L(last_2x_vec):
-	/* Check second to last VEC.  */
-	vmovdqu	-(VEC_SIZE * 2)(%rsi, %rdx), %ymm1
-	VPCMPEQ	-(VEC_SIZE * 2)(%rdi, %rdx), %ymm1, %ymm1
-	vpmovmskb %ymm1, %eax
-	incl	%eax
-	jnz	L(return_vec_1_end)
-	/* Check last VEC.  */
-L(last_1x_vec):
-	vmovdqu	-(VEC_SIZE * 1)(%rsi, %rdx), %ymm1
-	VPCMPEQ	-(VEC_SIZE * 1)(%rdi, %rdx), %ymm1, %ymm1
-	vpmovmskb %ymm1, %eax
-	incl	%eax
-	jnz	L(return_vec_0_end)
-	VZEROUPPER_RETURN
-
+    
 	.p2align 4
 L(8x_return_vec_2):
 	subq	$VEC_SIZE, %rdx
@@ -358,67 +463,6 @@ L(8x_return_vec_3):
 # endif
 	VZEROUPPER_RETURN
 
-	.p2align 4
-L(return_vec_1_end):
-	tzcntl	%eax, %eax
-	addl	%edx, %eax
-# ifdef USE_AS_WMEMCMP
-	movl	-(VEC_SIZE * 2)(%rdi, %rax), %ecx
-	xorl	%edx, %edx
-	cmpl	-(VEC_SIZE * 2)(%rsi, %rax), %ecx
-	setg	%dl
-	leal	-1(%rdx, %rdx), %eax
-# else
-	movzbl	-(VEC_SIZE * 2)(%rsi, %rax), %ecx
-	movzbl	-(VEC_SIZE * 2)(%rdi, %rax), %eax
-	subl	%ecx, %eax
-# endif
-	VZEROUPPER_RETURN
-
-	.p2align 4
-L(return_vec_0_end):
-	tzcntl	%eax, %eax
-	addl	%edx, %eax
-# ifdef USE_AS_WMEMCMP
-	movl	-VEC_SIZE(%rdi, %rax), %ecx
-	xorl	%edx, %edx
-	cmpl	-VEC_SIZE(%rsi, %rax), %ecx
-	setg	%dl
-	leal	-1(%rdx, %rdx), %eax
-# else
-	movzbl	-VEC_SIZE(%rsi, %rax), %ecx
-	movzbl	-VEC_SIZE(%rdi, %rax), %eax
-	subl	%ecx, %eax
-# endif
-	VZEROUPPER_RETURN
-
-	.p2align 4
-L(less_vec):
-	/* Check if one or less CHAR. This is necessary for size = 0 but
-	   is also faster for size = CHAR_SIZE.  */
-	cmpl	$CHAR_SIZE, %edx
-	jbe	L(one_or_less)
-
-	/* Check if loading one VEC from either s1 or s2 could cause a
-	   page cross. This can have false positives but is by far the
-	   fastest method.  */
-	movl	%edi, %eax
-	orl	%esi, %eax
-	andl	$(PAGE_SIZE - 1), %eax
-	cmpl	$(PAGE_SIZE - VEC_SIZE), %eax
-	jg	L(page_cross_less_vec)
-
-	/* No page cross possible.  */
-	vmovdqu	(%rsi), %ymm2
-	VPCMPEQ	(%rdi), %ymm2, %ymm2
-	vpmovmskb %ymm2, %eax
-	incl	%eax
-	/* Result will be zero if s1 and s2 match. Otherwise first set
-	   bit will be first mismatch.  */
-	bzhil	%edx, %eax, %edx
-	jnz	L(return_vec_0)
-	xorl	%eax, %eax
-	VZEROUPPER_RETURN
 
 	.p2align 4
 L(page_cross_less_vec):
@@ -430,30 +474,23 @@ L(page_cross_less_vec):
 	cmpl	$8, %edx
 	jae	L(between_8_15)
 	cmpl	$4, %edx
-	jae	L(between_4_7)
+	jb	L(between_2_3)
 
-	/* Load as big endian to avoid branches.  */
-	movzwl	(%rdi), %eax
-	movzwl	(%rsi), %ecx
-	shll	$8, %eax
-	shll	$8, %ecx
-	bswap	%eax
-	bswap	%ecx
-	movzbl	-1(%rdi, %rdx), %edi
-	movzbl	-1(%rsi, %rdx), %esi
-	orl	%edi, %eax
-	orl	%esi, %ecx
-	/* Subtraction is okay because the upper 8 bits are zero.  */
-	subl	%ecx, %eax
-	/* No ymm register was touched.  */
-	ret
-
-	.p2align 4
-L(one_or_less):
-	jb	L(zero)
-	movzbl	(%rsi), %ecx
-	movzbl	(%rdi), %eax
-	subl	%ecx, %eax
+	/* Load as big endian with overlapping movbe to avoid branches.
+	 */
+	movbe	(%rdi), %eax
+	movbe	(%rsi), %ecx
+	shlq	$32, %rax
+	shlq	$32, %rcx
+	movbe	-4(%rdi, %rdx), %edi
+	movbe	-4(%rsi, %rdx), %esi
+	orq	%rdi, %rax
+	orq	%rsi, %rcx
+	subq	%rcx, %rax
+	jz	L(zero_4_7)
+	sbbl	%eax, %eax
+	orl	$1, %eax
+L(zero_4_7):
 	/* No ymm register was touched.  */
 	ret
 
@@ -466,80 +503,54 @@ L(between_8_15):
 	VPCMPEQ	%xmm1, %xmm2, %xmm2
 	vpmovmskb %xmm2, %eax
 	subl	$0xffff, %eax
-	jnz	L(return_vec_0)
+	jnz	L(return_vec_0_start)
 	/* Use overlapping loads to avoid branches.  */
-	leaq	-8(%rdi, %rdx), %rdi
-	leaq	-8(%rsi, %rdx), %rsi
-	vmovq	(%rdi), %xmm1
-	vmovq	(%rsi), %xmm2
+	vmovq	-8(%rdi, %rdx), %xmm1
+	vmovq	-8(%rsi, %rdx), %xmm2
 	VPCMPEQ	%xmm1, %xmm2, %xmm2
+	addl	$(VEC_SIZE - 8), %edx
 	vpmovmskb %xmm2, %eax
 	subl	$0xffff, %eax
-	jnz	L(return_vec_0)
+	jnz	L(return_vec_0_end)
 	/* No ymm register was touched.  */
 	ret
 
-	.p2align 4
-L(zero):
-	xorl	%eax, %eax
-	ret
-
-	.p2align 4
+	.p2align 4,, 10
 L(between_16_31):
 	/* From 16 to 31 bytes.  No branch when size == 16.  */
-	vmovdqu	(%rsi), %xmm2
+	movups	(%rsi), %xmm2
 	VPCMPEQ	(%rdi), %xmm2, %xmm2
 	vpmovmskb %xmm2, %eax
 	subl	$0xffff, %eax
-	jnz	L(return_vec_0)
-
+	jnz	L(return_vec_0_start)
 	/* Use overlapping loads to avoid branches.  */
-
-	vmovdqu	-16(%rsi, %rdx), %xmm2
-	leaq	-16(%rdi, %rdx), %rdi
-	leaq	-16(%rsi, %rdx), %rsi
-	VPCMPEQ	(%rdi), %xmm2, %xmm2
+	movups	-16(%rsi, %rdx), %xmm2
+	VPCMPEQ	-16(%rdi, %rdx), %xmm2, %xmm2
+	addl	$(VEC_SIZE - 16), %edx
 	vpmovmskb %xmm2, %eax
 	subl	$0xffff, %eax
-	jnz	L(return_vec_0)
+	jnz	L(return_vec_0_end)
 	/* No ymm register was touched.  */
 	ret
 
-# ifdef USE_AS_WMEMCMP
-	.p2align 4
-L(one_or_less):
-	jb	L(zero)
-	movl	(%rdi), %ecx
-	xorl	%edx, %edx
-	cmpl	(%rsi), %ecx
-	je	L(zero)
-	setg	%dl
-	leal	-1(%rdx, %rdx), %eax
+# ifndef USE_AS_WMEMCMP
+	.p2align 4,, 8
+L(between_2_3):
+	/* Load as big endian to avoid branches.  */
+	movzwl	(%rdi), %eax
+	movzwl	(%rsi), %ecx
+	shll	$8, %eax
+	shll	$8, %ecx
+	bswap	%eax
+	bswap	%ecx
+	orb	-1(%rdi, %rdx), %al
+	orb	-1(%rsi, %rdx), %cl
+	/* Subtraction is okay because the upper 8 bits are zero.  */
+	subl	%ecx, %eax
 	/* No ymm register was touched.  */
 	ret
-# else
 
-	.p2align 4
-L(between_4_7):
-	/* Load as big endian with overlapping movbe to avoid branches.
-	 */
-	movbe	(%rdi), %eax
-	movbe	(%rsi), %ecx
-	shlq	$32, %rax
-	shlq	$32, %rcx
-	movbe	-4(%rdi, %rdx), %edi
-	movbe	-4(%rsi, %rdx), %esi
-	orq	%rdi, %rax
-	orq	%rsi, %rcx
-	subq	%rcx, %rax
-	jz	L(zero_4_7)
-	sbbl	%eax, %eax
-	orl	$1, %eax
-L(zero_4_7):
-	/* No ymm register was touched.  */
-	ret
 # endif
-
     .p2align 12
 END (MEMCMP)
 #endif
-- 
2.25.1

