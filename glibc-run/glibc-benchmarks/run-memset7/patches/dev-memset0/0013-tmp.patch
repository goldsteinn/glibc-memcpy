From 97b93dd2e90028db01923daa1231ed1ad2ee4c0a Mon Sep 17 00:00:00 2001
From: Noah Goldstein <goldstein.w.n@gmail.com>
Date: Fri, 24 Sep 2021 19:00:15 -0500
Subject: [PATCH 13/16] tmp

---
 .../multiarch/memset-vec-unaligned-erms.S     | 144 ++++++++++--------
 1 file changed, 79 insertions(+), 65 deletions(-)

diff --git a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
index 8fa65bddc1..349cedc781 100644
--- a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
+++ b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
@@ -181,33 +181,11 @@ ENTRY (MEMSET_SYMBOL (__memset, unaligned_erms))
 	VMOVU	%VEC(0), -VEC_SIZE(%rax, %rdx)
 	VZEROUPPER_RETURN
 #endif
-
-	.p2align 4
-L(loop_4x_vec):
-	leaq	(VEC_SIZE * 4 - LOOP_4X_OFFSET)(%rax), %rcx
-	andq	$-(VEC_SIZE * 2), %rcx
-#if LOOP_4X_OFFSET == 0
-	addq	$-(VEC_SIZE * 4), %rdi
-#endif
-	.p2align 4
-L(loop):
-	VMOVA	%VEC(0), (LOOP_4X_OFFSET)(%rcx)
-	VMOVA	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE)(%rcx)
-	VMOVA	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 2)(%rcx)
-	VMOVA	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 3)(%rcx)
-	subq	$-(VEC_SIZE * 4), %rcx
-	cmpq	%rdi, %rcx
-	jb	L(loop)
-	VMOVU	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 0)(%rdi)
-	VMOVU	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 1)(%rdi)
-	VMOVU	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 2)(%rdi)
-	VMOVU	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 3)(%rdi)
-L(return):
-#if VEC_SIZE > 16
-	ZERO_UPPER_VEC_REGISTERS_RETURN
-#else
-	ret
-#endif
+	.p2align 4,, 10
+L(last_2x_vec):
+	VMOVU	%VEC(0), (VEC_SIZE * -2)(%rdx)
+	VMOVU	%VEC(0), (VEC_SIZE * -1)(%rdx)
+	VZEROUPPER_RETURN
 
 #if defined USE_MULTIARCH && IS_IN (libc)
 	.p2align 4
@@ -216,26 +194,43 @@ L(stosb_more_2x_vec):
 	ja	L(stosb_close)
 #endif
 L(more_2x_vec):
-	addq	%rdx, %rdi
+	addq	%rdi, %rdx
+	subq	$-(VEC_SIZE * 4), %rdi
 	/* Stores to first 2x VEC before cmp as any path forward will
 	   require it.  */
 	VMOVU	%VEC(0), (%rax)
 	VMOVU	%VEC(0), VEC_SIZE(%rax)
-	cmpq	$(VEC_SIZE * 4), %rdx
-	jbe	L(last_2x_vec)
+	cmpq	%rdx, %rdi
+	jae	L(last_2x_vec)
 	VMOVU	%VEC(0), (VEC_SIZE * 2)(%rax)
 	VMOVU	%VEC(0), (VEC_SIZE * 3)(%rax)
 	/* Try and have this cmp/jcc on same cache line as target and
 	   fallthrough.  */
-	cmpq	$(VEC_SIZE * 8), %rdx
-	ja	L(loop_4x_vec)
-	VMOVU	%VEC(0), (VEC_SIZE * -4)(%rdi)
-	VMOVU	%VEC(0), (VEC_SIZE * -3)(%rdi)
-	.p2align 4,, SMALL_MOV_ALIGN(MOV_SIZE, 0)
-L(last_2x_vec):
-	VMOVU	%VEC(0), (VEC_SIZE * -2)(%rdi)
-	VMOVU	%VEC(0), (VEC_SIZE * -1)(%rdi)
-	VZEROUPPER_RETURN
+	addq	$-(VEC_SIZE * 4), %rdx
+	cmpq	%rdx, %rdi
+	jae	L(last_4x_vec)
+	andq	$(VEC_SIZE * -2), %rdi
+	.p2align 4
+L(loop):
+	VMOVA	%VEC(0), (VEC_SIZE * 0)(%rdi)
+	VMOVA	%VEC(0), (VEC_SIZE * 1)(%rdi)
+	VMOVA	%VEC(0), (VEC_SIZE * 2)(%rdi)
+	VMOVA	%VEC(0), (VEC_SIZE * 3)(%rdi)
+	subq	$-(VEC_SIZE * 4), %rdi
+	cmpq	%rdx, %rdi
+	jb	L(loop)
+L(last_4x_vec):
+	VMOVU	%VEC(0), (VEC_SIZE * 0)(%rdx)
+	VMOVU	%VEC(0), (VEC_SIZE * 1)(%rdx)
+	VMOVU	%VEC(0), (VEC_SIZE * 2)(%rdx)
+	VMOVU	%VEC(0), (VEC_SIZE * 3)(%rdx)
+L(return):
+#if VEC_SIZE > 16
+	ZERO_UPPER_VEC_REGISTERS_RETURN
+#else
+	ret
+#endif
+
 
 
 	.p2align 4,, 10
@@ -248,12 +243,46 @@ L(stosb_close):
 	VZEROUPPER_RETURN
 
 	.p2align 4,, 10
+#ifndef USE_LESS_VEC_MASK_STORE
 L(less_vec):
-	/* Less than 1 VEC.  */
-#if VEC_SIZE != 16 && VEC_SIZE != 32 && VEC_SIZE != 64
-# error Unsupported VEC_SIZE!
 #endif
+L(cross_page):
+#if VEC_SIZE > 32
+	cmpl	$32, %edx
+	jae	L(between_32_63)
+#endif
+#if VEC_SIZE > 16
+	cmpl	$16, %edx
+	jae	L(between_16_31)
+#endif
+	MOVQ	%XMM0, %rdi
+	cmpl	$8, %edx
+	jae	L(between_8_15)
+	cmpl	$4, %edx
+	jae	L(between_4_7)
+	cmpl	$1, %edx
+	ja	L(between_2_3)
+	jb	1f
+	movb	%sil, (%rax)
+1:
+	VZEROUPPER_RETURN
+
+#if VEC_SIZE == 32
+	.p2align 4,, SMALL_MOV_ALIGN(MOV_XMM_SIZE, RET_SIZE)
+L(between_16_31):
+	/* From 16 to 31.  No branch when size == 16.  */
+	VMOVU_XMM %XMM0, (%rax)
+	VMOVU_XMM %XMM0, -16(%rax, %rdx)
+	VZEROUPPER_RETURN
+#endif
+
 #ifdef USE_LESS_VEC_MASK_STORE
+	.p2align 4,, 10
+L(less_vec):
+	/* Less than 1 VEC.  */
+# if VEC_SIZE != 16 && VEC_SIZE != 32 && VEC_SIZE != 64
+#  error Unsupported VEC_SIZE!
+# endif
 	/* Clear high bits from edi. Only keeping bits relevant to page
 	   cross check. Note that we are using rax which is set in
 	   MEMSET_VDUP_TO_VEC0_AND_SET_RETURN as ptr from here on out.  */
@@ -276,27 +305,12 @@ L(less_vec):
 	VZEROUPPER_RETURN
 #endif
 
-	.p2align 4,, 10
-L(cross_page):
-#if VEC_SIZE > 32
-	cmpl	$32, %edx
-	jae	L(between_32_63)
-#endif
-#if VEC_SIZE > 16
-	cmpl	$16, %edx
-	jae	L(between_16_31)
-#endif
-	MOVQ	%XMM0, %rdi
-	cmpl	$8, %edx
-	jae	L(between_8_15)
-	cmpl	$4, %edx
-	jae	L(between_4_7)
-	cmpl	$1, %edx
-	ja	L(between_2_3)
-	jb	1f
-	movb	%sil, (%rax)
-1:
-	VZEROUPPER_RETURN
+
+
+
+
+
+
 #if VEC_SIZE > 32
 	.p2align 4,, SMALL_MOV_ALIGN(MOV_SIZE, RET_SIZE)
 	/* From 32 to 63.  No branch when size == 32.  */
@@ -304,8 +318,7 @@ L(between_32_63):
 	VMOVU	%YMM0, (%rax)
 	VMOVU	%YMM0, -32(%rax, %rdx)
 	VZEROUPPER_RETURN
-#endif
-#if VEC_SIZE > 16
+
 	.p2align 4,, SMALL_MOV_ALIGN(MOV_XMM_SIZE, RET_SIZE)
 L(between_16_31):
 	/* From 16 to 31.  No branch when size == 16.  */
@@ -313,6 +326,7 @@ L(between_16_31):
 	VMOVU_XMM %XMM0, -16(%rax, %rdx)
 	VZEROUPPER_RETURN
 #endif
+
 	.p2align 4,, SMALL_MOV_ALIGN(3, RET_SIZE)
 L(between_8_15):
 	/* From 8 to 15.  No branch when size == 8.  */
-- 
2.25.1

