From 8ddeefffb15983c5f287c71741f07c75800b66c0 Mon Sep 17 00:00:00 2001
From: Noah Goldstein <goldstein.w.n@gmail.com>
Date: Sat, 25 Sep 2021 19:07:48 -0500
Subject: [PATCH 15/16] tmp

---
 .../multiarch/memset-avx2-unaligned-erms.S    |   4 +-
 .../multiarch/memset-vec-unaligned-erms.S     | 162 ++++++++++--------
 2 files changed, 95 insertions(+), 71 deletions(-)

diff --git a/sysdeps/x86_64/multiarch/memset-avx2-unaligned-erms.S b/sysdeps/x86_64/multiarch/memset-avx2-unaligned-erms.S
index e9233c13ca..5ab9c7192c 100644
--- a/sysdeps/x86_64/multiarch/memset-avx2-unaligned-erms.S
+++ b/sysdeps/x86_64/multiarch/memset-avx2-unaligned-erms.S
@@ -1,14 +1,14 @@
 #if IS_IN (libc)
 # define VEC_SIZE	32
 # define MOV_SIZE     4
-# define MOV_XMM_SIZE 3
+# define MOV_XMM_SIZE 4
 # define RET_SIZE     4
 
 # define VEC(i)		ymm##i
 
 # define VMOVU     vmovdqu
 # define VMOVA     vmovdqa
-# define VMOVU_XMM movups
+# define VMOVU_XMM VMOVU
 
 # define MEMSET_VDUP_TO_VEC0_AND_SET_RETURN(d, r) \
   vmovd d, %xmm0; \
diff --git a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
index 349cedc781..2c05f83be2 100644
--- a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
+++ b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
@@ -65,7 +65,7 @@
 
 #define PAGE_SIZE 4096
 #if VEC_SIZE == 64
-# define LOOP_4X_OFFSET	(VEC_SIZE	*	-4)
+# define LOOP_4X_OFFSET	(VEC_SIZE	*	4)
 #else
 # define LOOP_4X_OFFSET	(0)
 #endif
@@ -181,12 +181,58 @@ ENTRY (MEMSET_SYMBOL (__memset, unaligned_erms))
 	VMOVU	%VEC(0), -VEC_SIZE(%rax, %rdx)
 	VZEROUPPER_RETURN
 #endif
+
 	.p2align 4,, 10
 L(last_2x_vec):
-	VMOVU	%VEC(0), (VEC_SIZE * -2)(%rdx)
-	VMOVU	%VEC(0), (VEC_SIZE * -1)(%rdx)
+#ifdef USE_LESS_VEC_MASK_STORE
+	VMOVU	%VEC(0), (VEC_SIZE * 2 + LOOP_4X_OFFSET)(%rcx)
+	VMOVU	%VEC(0), (VEC_SIZE * 3 + LOOP_4X_OFFSET)(%rcx)
+#else
+	VMOVU	%VEC(0), (VEC_SIZE * -2)(%rdi)
+	VMOVU	%VEC(0), (VEC_SIZE * -1)(%rdi)
+#endif
 	VZEROUPPER_RETURN
 
+#ifdef USE_LESS_VEC_MASK_STORE
+	.p2align 4,, 10
+L(less_vec):
+	/* Less than 1 VEC.  */
+# if VEC_SIZE != 16 && VEC_SIZE != 32 && VEC_SIZE != 64
+#  error Unsupported VEC_SIZE!
+# endif
+	/* Clear high bits from edi. Only keeping bits relevant to page
+	   cross check. Note that we are using rax which is set in
+	   MEMSET_VDUP_TO_VEC0_AND_SET_RETURN as ptr from here on out.  */
+	andl	$(PAGE_SIZE - 1), %edi
+	/* Check if VEC_SIZE store cross page. Mask stores suffer
+	   serious performance degradation when it has to fault supress.
+	 */
+	cmpl	$(PAGE_SIZE - VEC_SIZE), %edi
+	ja	L(cross_page)
+# if VEC_SIZE > 32
+	movq	$-1, %rcx
+	bzhiq	%rdx, %rcx, %rcx
+	kmovq	%rcx, %k1
+# else
+	movl	$-1, %ecx
+	bzhil	%edx, %ecx, %ecx
+	kmovd	%ecx, %k1
+# endif
+	vmovdqu8 %VEC(0), (%rax){%k1}
+	VZEROUPPER_RETURN
+
+	.p2align 4,, 10
+L(stosb_close):
+	movzbl	%sil, %eax
+	mov	%RDX_LP, %RCX_LP
+	mov	%RDI_LP, %RDX_LP
+	rep	stosb
+	mov	%RDX_LP, %RAX_LP
+	VZEROUPPER_RETURN
+#endif
+
+
+
 #if defined USE_MULTIARCH && IS_IN (libc)
 	.p2align 4
 L(stosb_more_2x_vec):
@@ -194,45 +240,63 @@ L(stosb_more_2x_vec):
 	ja	L(stosb_close)
 #endif
 L(more_2x_vec):
-	addq	%rdi, %rdx
-	subq	$-(VEC_SIZE * 4), %rdi
+#ifdef USE_LESS_VEC_MASK_STORE
+	leaq	-(VEC_SIZE * 4 + LOOP_4X_OFFSET)(%rdi, %rdx), %rcx
+#endif
+
 	/* Stores to first 2x VEC before cmp as any path forward will
 	   require it.  */
 	VMOVU	%VEC(0), (%rax)
 	VMOVU	%VEC(0), VEC_SIZE(%rax)
-	cmpq	%rdx, %rdi
-	jae	L(last_2x_vec)
+#ifndef USE_LESS_VEC_MASK_STORE
+	addq	%rdx, %rdi
+#endif
+	cmpq	$(VEC_SIZE * 4), %rdx
+	jbe	L(last_2x_vec)
 	VMOVU	%VEC(0), (VEC_SIZE * 2)(%rax)
 	VMOVU	%VEC(0), (VEC_SIZE * 3)(%rax)
 	/* Try and have this cmp/jcc on same cache line as target and
 	   fallthrough.  */
-	addq	$-(VEC_SIZE * 4), %rdx
-	cmpq	%rdx, %rdi
-	jae	L(last_4x_vec)
-	andq	$(VEC_SIZE * -2), %rdi
+#ifdef USE_LESS_VEC_MASK_STORE
+# if LOOP_4X_OFFSET == 0
+	subq	$-(VEC_SIZE * 4), %rdi
+# endif
+	cmpq	%rdi, %rcx
+# define LOOP_VEC	rdi
+# define END_VEC	rcx
+#else
+	addq	$-(VEC_SIZE * 4), %rdi
+	cmpq	$(VEC_SIZE * 8), %rdx
+# define LOOP_VEC	rdx
+# define END_VEC	rdi
+#endif
+	jbe	L(last_4x_vec)
+#ifndef USE_LESS_VEC_MASK_STORE
+	leaq	(VEC_SIZE * 4)(%rax), %LOOP_VEC
+#endif
+	andq	$(VEC_SIZE * -2), %LOOP_VEC
 	.p2align 4
 L(loop):
-	VMOVA	%VEC(0), (VEC_SIZE * 0)(%rdi)
-	VMOVA	%VEC(0), (VEC_SIZE * 1)(%rdi)
-	VMOVA	%VEC(0), (VEC_SIZE * 2)(%rdi)
-	VMOVA	%VEC(0), (VEC_SIZE * 3)(%rdi)
-	subq	$-(VEC_SIZE * 4), %rdi
-	cmpq	%rdx, %rdi
+	VMOVA	%VEC(0), (VEC_SIZE * 0 + LOOP_4X_OFFSET)(%LOOP_VEC)
+	VMOVA	%VEC(0), (VEC_SIZE * 1 + LOOP_4X_OFFSET)(%LOOP_VEC)
+	VMOVA	%VEC(0), (VEC_SIZE * 2 + LOOP_4X_OFFSET)(%LOOP_VEC)
+	VMOVA	%VEC(0), (VEC_SIZE * 3 + LOOP_4X_OFFSET)(%LOOP_VEC)
+	subq	$-(VEC_SIZE * 4), %LOOP_VEC
+	cmpq	%END_VEC, %LOOP_VEC
 	jb	L(loop)
+	.p2align 4,, MOV_SIZE
 L(last_4x_vec):
-	VMOVU	%VEC(0), (VEC_SIZE * 0)(%rdx)
-	VMOVU	%VEC(0), (VEC_SIZE * 1)(%rdx)
-	VMOVU	%VEC(0), (VEC_SIZE * 2)(%rdx)
-	VMOVU	%VEC(0), (VEC_SIZE * 3)(%rdx)
+	VMOVU	%VEC(0), (VEC_SIZE * 0 + LOOP_4X_OFFSET)(%END_VEC)
+	VMOVU	%VEC(0), (VEC_SIZE * 1 + LOOP_4X_OFFSET)(%END_VEC)
+	VMOVU	%VEC(0), (VEC_SIZE * 2 + LOOP_4X_OFFSET)(%END_VEC)
+	VMOVU	%VEC(0), (VEC_SIZE * 3 + LOOP_4X_OFFSET)(%END_VEC)
 L(return):
 #if VEC_SIZE > 16
 	ZERO_UPPER_VEC_REGISTERS_RETURN
 #else
 	ret
 #endif
-
-
-
+#ifndef USE_LESS_VEC_MASK_STORE
 	.p2align 4,, 10
 L(stosb_close):
 	movzbl	%sil, %eax
@@ -242,8 +306,7 @@ L(stosb_close):
 	mov	%RDX_LP, %RAX_LP
 	VZEROUPPER_RETURN
 
-	.p2align 4,, 10
-#ifndef USE_LESS_VEC_MASK_STORE
+	.p2align 4
 L(less_vec):
 #endif
 L(cross_page):
@@ -267,49 +330,6 @@ L(cross_page):
 1:
 	VZEROUPPER_RETURN
 
-#if VEC_SIZE == 32
-	.p2align 4,, SMALL_MOV_ALIGN(MOV_XMM_SIZE, RET_SIZE)
-L(between_16_31):
-	/* From 16 to 31.  No branch when size == 16.  */
-	VMOVU_XMM %XMM0, (%rax)
-	VMOVU_XMM %XMM0, -16(%rax, %rdx)
-	VZEROUPPER_RETURN
-#endif
-
-#ifdef USE_LESS_VEC_MASK_STORE
-	.p2align 4,, 10
-L(less_vec):
-	/* Less than 1 VEC.  */
-# if VEC_SIZE != 16 && VEC_SIZE != 32 && VEC_SIZE != 64
-#  error Unsupported VEC_SIZE!
-# endif
-	/* Clear high bits from edi. Only keeping bits relevant to page
-	   cross check. Note that we are using rax which is set in
-	   MEMSET_VDUP_TO_VEC0_AND_SET_RETURN as ptr from here on out.  */
-	andl	$(PAGE_SIZE - 1), %edi
-	/* Check if VEC_SIZE store cross page. Mask stores suffer
-	   serious performance degradation when it has to fault supress.
-	 */
-	cmpl	$(PAGE_SIZE - VEC_SIZE), %edi
-	ja	L(cross_page)
-# if VEC_SIZE > 32
-	movq	$-1, %rcx
-	bzhiq	%rdx, %rcx, %rcx
-	kmovq	%rcx, %k1
-# else
-	movl	$-1, %ecx
-	bzhil	%edx, %ecx, %ecx
-	kmovd	%ecx, %k1
-# endif
-	vmovdqu8 %VEC(0), (%rax){%k1}
-	VZEROUPPER_RETURN
-#endif
-
-
-
-
-
-
 
 #if VEC_SIZE > 32
 	.p2align 4,, SMALL_MOV_ALIGN(MOV_SIZE, RET_SIZE)
@@ -318,7 +338,9 @@ L(between_32_63):
 	VMOVU	%YMM0, (%rax)
 	VMOVU	%YMM0, -32(%rax, %rdx)
 	VZEROUPPER_RETURN
+#endif
 
+#if VEC_SIZE >= 32
 	.p2align 4,, SMALL_MOV_ALIGN(MOV_XMM_SIZE, RET_SIZE)
 L(between_16_31):
 	/* From 16 to 31.  No branch when size == 16.  */
@@ -327,6 +349,8 @@ L(between_16_31):
 	VZEROUPPER_RETURN
 #endif
 
+
+
 	.p2align 4,, SMALL_MOV_ALIGN(3, RET_SIZE)
 L(between_8_15):
 	/* From 8 to 15.  No branch when size == 8.  */
-- 
2.25.1

