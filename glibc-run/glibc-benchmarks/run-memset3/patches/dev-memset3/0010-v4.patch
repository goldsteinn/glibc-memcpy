From d4ab8a13fa1d8ef8f3187e3ca476a43e0ec7eca6 Mon Sep 17 00:00:00 2001
From: Noah Goldstein <goldstein.w.n@gmail.com>
Date: Thu, 23 Sep 2021 00:01:55 -0500
Subject: [PATCH 10/13] v4

---
 .../multiarch/memset-vec-unaligned-erms.S     | 124 ++++++------------
 1 file changed, 42 insertions(+), 82 deletions(-)

diff --git a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
index 3385a0506c..20366f1772 100644
--- a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
+++ b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
@@ -64,7 +64,11 @@
 #endif
 
 #define PAGE_SIZE 4096
-#define LOOP_4X_OFFSET	(VEC_SIZE	*	-4)
+#if VEC_SIZE == 64
+# define LOOP_4X_OFFSET	(VEC_SIZE	*	-4)
+#else
+# define LOOP_4X_OFFSET	(0)
+#endif
 #define SMALL_MOV_ALIGN(mov_sz,	ret_sz)	(2	*	(mov_sz)	+	(ret_sz))
 #ifndef SECTION
 # error SECTION is not defined!
@@ -109,62 +113,6 @@ ENTRY (MEMSET_SYMBOL (__memset, unaligned))
 # ifdef __ILP32__
 	/* Clear the upper 32 bits.  */
 	mov	%edx, %edx
-# endif
-L(entry_from_bzero):
-	cmpq	$VEC_SIZE, %rdx
-	jb	L(less_vec)
-	cmpq	$(VEC_SIZE * 2), %rdx
-	ja	L(more_2x_vec)
-	/* From VEC and to 2 * VEC.  No branch when size == VEC_SIZE.  */
-	VMOVU	%VEC(0), -VEC_SIZE(%rdi,%rdx)
-	VMOVU	%VEC(0), (%rdi)
-	VZEROUPPER_RETURN
-#if defined USE_MULTIARCH && IS_IN (libc)
-END (MEMSET_SYMBOL (__memset, unaligned))
-
-# if VEC_SIZE == 16
-ENTRY (__memset_chk_erms)
-	cmp	%RDX_LP, %RCX_LP
-	jb	HIDDEN_JUMPTARGET (__chk_fail)
-END (__memset_chk_erms)
-
-/* Only used to measure performance of REP STOSB.  */
-ENTRY (__memset_erms)
-	/* Skip zero length.  */
-	test	%RDX_LP, %RDX_LP
-	jnz	 L(stosb)
-	movq	%rdi, %rax
-	ret
-# else
-/* Provide a hidden symbol to debugger.  */
-	.hidden	MEMSET_SYMBOL (__memset, erms)
-ENTRY (MEMSET_SYMBOL (__memset, erms))
-# endif
-L(stosb):
-	mov	%RDX_LP, %RCX_LP
-	movzbl	%sil, %eax
-	mov	%RDI_LP, %RDX_LP
-	rep stosb
-	mov	%RDX_LP, %RAX_LP
-	VZEROUPPER_RETURN
-# if VEC_SIZE == 16
-END (__memset_erms)
-# else
-END (MEMSET_SYMBOL (__memset, erms))
-# endif
-
-# if defined SHARED && IS_IN (libc)
-ENTRY_CHK (MEMSET_CHK_SYMBOL (__memset_chk, unaligned_erms))
-	cmp	%RDX_LP, %RCX_LP
-	jb	HIDDEN_JUMPTARGET (__chk_fail)
-END_CHK (MEMSET_CHK_SYMBOL (__memset_chk, unaligned_erms))
-# endif
-
-ENTRY (MEMSET_SYMBOL (__memset, unaligned_erms))
-	MEMSET_VDUP_TO_VEC0_AND_SET_RETURN (%esi, %rdi)
-# ifdef __ILP32__
-	/* Clear the upper 32 bits.  */
-	mov	%edx, %edx
 # endif
 	cmp	$VEC_SIZE, %RDX_LP
 	jb	L(less_vec)
@@ -186,7 +134,7 @@ L(last_2x_vec):
 	.p2align 4
 #if defined USE_MULTIARCH && IS_IN (libc)
 L(stosb_more_2x_vec):
-	cmp     $2048, %RDX_LP
+	cmp	x86_rep_stosb_threshold(%rip), %RDX_LP
 	ja	L(stosb_close)
 #endif
 L(more_2x_vec):
@@ -195,38 +143,23 @@ L(more_2x_vec):
 	   require it.  */
 	VMOVU	%VEC(0), (%rax)
 	VMOVU	%VEC(0), VEC_SIZE(%rax)
+
 	cmpq	$(VEC_SIZE * 4), %rdx
 	jbe	L(last_2x_vec)
 	VMOVU	%VEC(0), (VEC_SIZE * 2)(%rax)
 	VMOVU	%VEC(0), (VEC_SIZE * 3)(%rax)
-
+	/* Try and have this cmp/jcc on same cache line as target and
+	   fallthrough.  */
 	cmpq	$(VEC_SIZE * 8), %rdx
-	jbe	L(last_4x_vec)
-	leaq	(VEC_SIZE * 8)(%rax), %rcx
-	andq	$-(VEC_SIZE * 2), %rcx
-	.p2align 4
-L(loop):
-	VMOVA	%VEC(0), (VEC_SIZE * -4)(%rcx)
-	VMOVA	%VEC(0), (VEC_SIZE * -3)(%rcx)
-	VMOVA	%VEC(0), (VEC_SIZE * -2)(%rcx)
-	VMOVA	%VEC(0), (VEC_SIZE * -1)(%rcx)
-	subq	$-(VEC_SIZE * 4), %rcx
-	cmpq	%rdi, %rcx
-	jb	L(loop)
-	.p2align 4,, 8
-L(last_4x_vec):
+	ja	L(loop_4x_vec)
 	VMOVU	%VEC(0), (VEC_SIZE * -4)(%rdi)
 	VMOVU	%VEC(0), (VEC_SIZE * -3)(%rdi)
 	VMOVU	%VEC(0), (VEC_SIZE * -2)(%rdi)
 	VMOVU	%VEC(0), (VEC_SIZE * -1)(%rdi)
-L(return):
-#if VEC_SIZE > 16
-	ZERO_UPPER_VEC_REGISTERS_RETURN
-#else
-	ret
-#endif
-#if defined USE_MULTIARCH && IS_IN (libc)
+	VZEROUPPER_RETURN
+
 	.p2align 4,, 10
+#if defined USE_MULTIARCH && IS_IN (libc)
 L(stosb_close):
 	movzbl	%sil, %eax
 	mov	%RDX_LP, %RCX_LP
@@ -235,8 +168,35 @@ L(stosb_close):
 	mov	%RDX_LP, %RAX_LP
 	VZEROUPPER_RETURN
 #endif
+
+	.p2align 5
+L(loop_4x_vec):
+	leaq	(VEC_SIZE * 4 - LOOP_4X_OFFSET)(%rax), %rcx
+	andq	$-(VEC_SIZE * 2), %rcx
+#if LOOP_4X_OFFSET == 0
+	addq	$-(VEC_SIZE * 4), %rdi
+#endif
+	.p2align 4
+L(loop):
+	VMOVA	%VEC(0), (LOOP_4X_OFFSET)(%rcx)
+	VMOVA	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE)(%rcx)
+	VMOVA	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 2)(%rcx)
+	VMOVA	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 3)(%rcx)
+	subq	$-(VEC_SIZE * 4), %rcx
+	cmpq	%rdi, %rcx
+	jb	L(loop)
+	VMOVU	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 0)(%rdi)
+	VMOVU	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 1)(%rdi)
+	VMOVU	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 2)(%rdi)
+	VMOVU	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 3)(%rdi)
+L(return):
+#if VEC_SIZE > 16
+	ZERO_UPPER_VEC_REGISTERS_RETURN
+#else
+	ret
+#endif
+
 	.p2align 4
-	.p2align 6,, 16
 L(less_vec):
 	/* Less than 1 VEC.  */
 #if VEC_SIZE != 16 && VEC_SIZE != 32 && VEC_SIZE != 64
@@ -265,7 +225,7 @@ L(less_vec):
 	VZEROUPPER_RETURN
 #endif
 
-	.p2align 4,, 10
+	.p2align 4
 L(cross_page):
 #if VEC_SIZE > 32
 	cmpl	$32, %edx
-- 
2.25.1

