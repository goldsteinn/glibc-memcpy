From 2270572312c29e1d150651c7017abbe620ceb6da Mon Sep 17 00:00:00 2001
From: Noah Goldstein <goldstein.w.n@gmail.com>
Date: Thu, 23 Sep 2021 00:02:33 -0500
Subject: [PATCH 11/13] v4

---
 .../multiarch/memset-vec-unaligned-erms.S     | 70 ++++++++-----------
 1 file changed, 30 insertions(+), 40 deletions(-)

diff --git a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
index 20366f1772..708cf9461a 100644
--- a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
+++ b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
@@ -116,12 +116,13 @@ ENTRY (MEMSET_SYMBOL (__memset, unaligned))
 # endif
 	cmp	$VEC_SIZE, %RDX_LP
 	jb	L(less_vec)
+	addq	%rdx, %rdi
 	cmp	$(VEC_SIZE * 2), %RDX_LP
 	ja	L(stosb_more_2x_vec)
 	/* From VEC and to 2 * VEC.  No branch when size == VEC_SIZE.
 	 */
 	VMOVU	%VEC(0), (%rax)
-	VMOVU	%VEC(0), -VEC_SIZE(%rax, %rdx)
+	VMOVU	%VEC(0), -VEC_SIZE(%rdi)
 	VZEROUPPER_RETURN
 #endif
 
@@ -134,69 +135,58 @@ L(last_2x_vec):
 	.p2align 4
 #if defined USE_MULTIARCH && IS_IN (libc)
 L(stosb_more_2x_vec):
-	cmp	x86_rep_stosb_threshold(%rip), %RDX_LP
+	// cmp     x86_rep_stosb_threshold(%rip), %RDX_LP
+	cmp	$4096, %RDX_LP
 	ja	L(stosb_close)
 #endif
 L(more_2x_vec):
-	addq	%rdx, %rdi
 	/* Stores to first 2x VEC before cmp as any path forward will
 	   require it.  */
 	VMOVU	%VEC(0), (%rax)
 	VMOVU	%VEC(0), VEC_SIZE(%rax)
-
 	cmpq	$(VEC_SIZE * 4), %rdx
 	jbe	L(last_2x_vec)
 	VMOVU	%VEC(0), (VEC_SIZE * 2)(%rax)
 	VMOVU	%VEC(0), (VEC_SIZE * 3)(%rax)
-	/* Try and have this cmp/jcc on same cache line as target and
-	   fallthrough.  */
-	cmpq	$(VEC_SIZE * 8), %rdx
-	ja	L(loop_4x_vec)
-	VMOVU	%VEC(0), (VEC_SIZE * -4)(%rdi)
-	VMOVU	%VEC(0), (VEC_SIZE * -3)(%rdi)
-	VMOVU	%VEC(0), (VEC_SIZE * -2)(%rdi)
-	VMOVU	%VEC(0), (VEC_SIZE * -1)(%rdi)
-	VZEROUPPER_RETURN
-
-	.p2align 4,, 10
-#if defined USE_MULTIARCH && IS_IN (libc)
-L(stosb_close):
-	movzbl	%sil, %eax
-	mov	%RDX_LP, %RCX_LP
-	mov	%RDI_LP, %RDX_LP
-	rep	stosb
-	mov	%RDX_LP, %RAX_LP
-	VZEROUPPER_RETURN
-#endif
 
-	.p2align 5
-L(loop_4x_vec):
-	leaq	(VEC_SIZE * 4 - LOOP_4X_OFFSET)(%rax), %rcx
+	cmpq	$(VEC_SIZE * 8), %rdx
+	jbe	L(last_4x_vec)
+	leaq	(VEC_SIZE * 8)(%rax), %rcx
 	andq	$-(VEC_SIZE * 2), %rcx
-#if LOOP_4X_OFFSET == 0
-	addq	$-(VEC_SIZE * 4), %rdi
-#endif
 	.p2align 4
 L(loop):
-	VMOVA	%VEC(0), (LOOP_4X_OFFSET)(%rcx)
-	VMOVA	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE)(%rcx)
-	VMOVA	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 2)(%rcx)
-	VMOVA	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 3)(%rcx)
+	VMOVA	%VEC(0), (VEC_SIZE * -4)(%rcx)
+	VMOVA	%VEC(0), (VEC_SIZE * -3)(%rcx)
+	VMOVA	%VEC(0), (VEC_SIZE * -2)(%rcx)
+	VMOVA	%VEC(0), (VEC_SIZE * -1)(%rcx)
 	subq	$-(VEC_SIZE * 4), %rcx
 	cmpq	%rdi, %rcx
 	jb	L(loop)
-	VMOVU	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 0)(%rdi)
-	VMOVU	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 1)(%rdi)
-	VMOVU	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 2)(%rdi)
-	VMOVU	%VEC(0), (LOOP_4X_OFFSET + VEC_SIZE * 3)(%rdi)
+	.p2align 4,, 8
+L(last_4x_vec):
+	VMOVU	%VEC(0), (VEC_SIZE * -4)(%rdi)
+	VMOVU	%VEC(0), (VEC_SIZE * -3)(%rdi)
+	VMOVU	%VEC(0), (VEC_SIZE * -2)(%rdi)
+	VMOVU	%VEC(0), (VEC_SIZE * -1)(%rdi)
 L(return):
 #if VEC_SIZE > 16
 	ZERO_UPPER_VEC_REGISTERS_RETURN
 #else
 	ret
 #endif
-
+#if defined USE_MULTIARCH && IS_IN (libc)
+	.p2align 4,, 10
+L(stosb_close):
+	mov	%RAX_LP, %RDI_LP
+	movzbl	%sil, %eax
+	mov	%RDX_LP, %RCX_LP
+    mov	%RDI_LP, %RDX_LP
+	rep	stosb
+	mov	%RDX_LP, %RAX_LP
+	VZEROUPPER_RETURN
+#endif
 	.p2align 4
+	.p2align 6,, 16
 L(less_vec):
 	/* Less than 1 VEC.  */
 #if VEC_SIZE != 16 && VEC_SIZE != 32 && VEC_SIZE != 64
@@ -225,7 +215,7 @@ L(less_vec):
 	VZEROUPPER_RETURN
 #endif
 
-	.p2align 4
+	.p2align 4,, 10
 L(cross_page):
 #if VEC_SIZE > 32
 	cmpl	$32, %edx
-- 
2.25.1

